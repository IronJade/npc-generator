/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NPCGenerator
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/utils/npc-generation.ts
var NPCGenerationUtils = class {
  /**
   * Roll ability scores using 4d6 drop lowest method
   * @returns AbilityScores object
   */
  static generateAbilityScores() {
    const rollAbilityScore = () => {
      const rolls = Array(4).fill(0).map(() => Math.floor(Math.random() * 6) + 1);
      rolls.sort((a, b) => a - b);
      rolls.shift();
      return rolls.reduce((a, b) => a + b, 0);
    };
    return {
      str: rollAbilityScore(),
      dex: rollAbilityScore(),
      con: rollAbilityScore(),
      int: rollAbilityScore(),
      wis: rollAbilityScore(),
      cha: rollAbilityScore()
    };
  }
  /**
   * Calculate ability modifiers
   * @param abilityScores 
   * @returns Partial ability modifiers
   */
  static calculateAbilityModifiers(abilityScores) {
    return Object.fromEntries(
      Object.entries(abilityScores).map(([ability, score]) => [
        ability,
        Math.floor((score - 10) / 2)
      ])
    );
  }
  /**
   * Generate a random alignment
   * @returns Alignment
   */
  static generateAlignment() {
    const lawfulness = ["Lawful", "Neutral", "Chaotic"];
    const goodness = ["Good", "Neutral", "Evil"];
    const lawChoice = lawfulness[Math.floor(Math.random() * lawfulness.length)];
    const goodChoice = goodness[Math.floor(Math.random() * goodness.length)];
    if (lawChoice === "Neutral" && goodChoice === "Neutral") {
      return "Neutral";
    }
    return `${lawChoice} ${goodChoice}`;
  }
  /**
   * Generate a name based on race
   * @param race Race object
   * @returns string
   */
  static generateName(race) {
    const namesByRace = {
      "Human": {
        first: ["James", "John", "Mary", "Emma", "Liam", "Olivia", "William", "Ava", "Sophia", "Lucas"],
        last: ["Smith", "Johnson", "Brown", "Williams", "Jones", "Miller", "Davis", "Garcia", "Rodriguez", "Wilson"]
      },
      "Elf": {
        first: ["Aerith", "Legolas", "Elrond", "Galadriel", "Thranduil", "Arwen", "Celeborn", "Tauriel", "Haldir", "F\xEBanor"],
        last: ["Silverleaf", "Starweaver", "Moonshadow", "Windrider", "Dawnbringer", "Nightwalker", "Sunseeker", "Forestborn", "Lightbringer", "Swiftarrow"]
      },
      "Dwarf": {
        first: ["Thorin", "Gimli", "Balin", "Dwalin", "Gloin", "Bombur", "Dori", "Nori", "Ori", "Fili"],
        last: ["Ironforge", "Stonebeard", "Rockfist", "Deepdelver", "Goldseeker", "Anvilheart", "Hammerstrike", "Mithrilsoul", "Copperfury", "Flintcrag"]
      },
      "Halfling": {
        first: ["Bilbo", "Frodo", "Sam", "Merry", "Pippin", "Rosie", "Elanor", "Hamfast", "Adelard", "Esmeralda"],
        last: ["Baggins", "Gamgee", "Took", "Brandybuck", "Proudfoot", "Bolger", "Smallburrow", "Chubb", "Goodbody", "Boffin"]
      }
      // Add other races similarly...
    };
    const nameOptions = namesByRace[race.name] || namesByRace["Human"];
    const firstName = nameOptions.first[Math.floor(Math.random() * nameOptions.first.length)];
    const lastName = nameOptions.last[Math.floor(Math.random() * nameOptions.last.length)];
    return `${firstName} ${lastName}`;
  }
  /**
   * Calculate hit points for an NPC
   * @param characterClass Character's class
   * @param conModifier Constitution modifier
   * @param level Character level
   * @returns number
   */
  static calculateHitPoints(characterClass, conModifier, level) {
    const firstLevelHP = characterClass.hitDie + conModifier;
    const subsequentLevelsHP = (characterClass.hitDie / 2 + 1 + conModifier) * (level - 1);
    return Math.floor(firstLevelHP + subsequentLevelsHP);
  }
  /**
   * Calculate proficiency bonus based on level
   * @param level Character level
   * @returns number
   */
  static calculateProficiencyBonus(level) {
    return Math.ceil(level / 4) + 1;
  }
  /**
   * Apply racial ability score adjustments
   * @param baseScores Original ability scores
   * @param race Race with adjustments
   * @returns Adjusted ability scores
   */
  static applyRacialAdjustments(baseScores, race) {
    return {
      str: baseScores.str + (race.abilityScoreAdjustments.str || 0),
      dex: baseScores.dex + (race.abilityScoreAdjustments.dex || 0),
      con: baseScores.con + (race.abilityScoreAdjustments.con || 0),
      int: baseScores.int + (race.abilityScoreAdjustments.int || 0),
      wis: baseScores.wis + (race.abilityScoreAdjustments.wis || 0),
      cha: baseScores.cha + (race.abilityScoreAdjustments.cha || 0)
    };
  }
  /**
   * Generate skills for an NPC
   * @param characterClass Character's class
   * @param abilityModifiers Ability modifiers
   * @param level Character level
   * @returns Record of skills and their bonuses
   */
  static generateSkills(characterClass, abilityModifiers, level) {
    const allSkills = {
      "Acrobatics": "dex",
      "Animal Handling": "wis",
      "Arcana": "int",
      "Athletics": "str",
      "Deception": "cha",
      "History": "int",
      "Insight": "wis",
      "Intimidation": "cha",
      "Investigation": "int",
      "Medicine": "wis",
      "Nature": "int",
      "Perception": "wis",
      "Performance": "cha",
      "Persuasion": "cha",
      "Religion": "int",
      "Sleight of Hand": "dex",
      "Stealth": "dex",
      "Survival": "wis"
    };
    const proficiencyBonus = this.calculateProficiencyBonus(level);
    const skills = {};
    for (const [skill, ability] of Object.entries(allSkills)) {
      skills[skill] = abilityModifiers[ability] || 0;
    }
    const numProficiencies = characterClass.skillChoices || 2;
    const availableSkills = [...characterClass.skills];
    const proficientSkills = [];
    while (proficientSkills.length < numProficiencies && availableSkills.length > 0) {
      const randomIndex = Math.floor(Math.random() * availableSkills.length);
      const skill = availableSkills.splice(randomIndex, 1)[0];
      if (!proficientSkills.includes(skill)) {
        proficientSkills.push(skill);
      }
    }
    for (const skill of proficientSkills) {
      skills[skill] += proficiencyBonus;
    }
    return skills;
  }
};

// src/utils/possessions.ts
var PossessionsUtils = class {
  /**
   * Generate possessions for an NPC
   * @param characterClass Character's class
   * @returns Array of possessions
   */
  static generatePossessions(characterClass) {
    const baseEquipment = this.classEquipment[characterClass.name] || this.classEquipment["Fighter"];
    if (Math.random() >= 0.75) {
      return this.addSpecialItems(baseEquipment);
    }
    return baseEquipment;
  }
  /**
   * Add special items to base equipment
   * @param baseEquipment Base equipment list
   * @returns Enhanced equipment list
   */
  static addSpecialItems(baseEquipment) {
    const availableSpecialItems = [...this.specialItems];
    const numSpecialItems = Math.floor(Math.random() * 3) + 1;
    const specialItemsToAdd = [];
    for (let i = 0; i < numSpecialItems; i++) {
      if (availableSpecialItems.length === 0) break;
      const randomIndex = Math.floor(Math.random() * availableSpecialItems.length);
      specialItemsToAdd.push(availableSpecialItems.splice(randomIndex, 1)[0]);
    }
    return [...baseEquipment, ...specialItemsToAdd];
  }
  /**
   * Format possessions for display
   * @param possessions List of possessions
   * @returns Formatted possession strings
   */
  static formatPossessions(possessions) {
    return possessions.map((item) => {
      if (typeof item === "string") return item;
      return item.desc ? `${item.name} (${item.desc})` : item.name;
    });
  }
};
/**
 * Base equipment for different classes
 */
PossessionsUtils.classEquipment = {
  "Fighter": [
    "Longsword",
    "Shield",
    "Chain mail",
    "Backpack",
    "Bedroll",
    "Tinderbox",
    "10 torches",
    "10 days of rations",
    "Waterskin",
    "50 ft of rope"
  ],
  "Rogue": [
    "Shortsword",
    "Shortbow with 20 arrows",
    "Leather armor",
    "Thieves' tools",
    "Backpack",
    "50 ft of silk rope",
    "Dark clothes",
    "Hood",
    "Belt pouch",
    "10 days of rations"
  ],
  "Wizard": [
    "Spellbook",
    "Quarterstaff",
    "Component pouch",
    "Scholar's pack",
    "Backpack",
    "Bottle of ink",
    "Ink pen",
    "10 sheets of parchment",
    "Little bag of sand",
    "Small knife"
  ],
  "Cleric": [
    "Mace",
    "Scale mail",
    "Shield",
    "Holy symbol",
    "Priest's pack",
    "Backpack",
    "Blanket",
    "10 candles",
    "Tinderbox",
    "Alms box"
  ],
  "Barbarian": [
    "Greataxe",
    "Two handaxes",
    "Explorer's pack",
    "Four javelins",
    "Backpack",
    "Bedroll",
    "Mess kit",
    "Tinderbox",
    "10 days of rations",
    "Waterskin"
  ]
};
/**
 * List of possible special items
 */
PossessionsUtils.specialItems = [
  { name: "gold pocket watch", desc: "valued at 10 Golds" },
  { name: "intricately carved wood pipe" },
  { name: "pouch half-filled with pipe weed that has a maple honey scent" },
  { name: "Potion of Greater Healing" },
  { name: "1 Plats, 12 Golds, 17 Lecs, and 5 Silvs in a leather purse" },
  { name: "mysterious key", desc: "made of a strange blue metal" },
  { name: "small trinket", desc: "from their hometown" }
];

// src/utils/spellcasting.ts
var SpellcastingUtils = class {
  /**
   * Determine if a class is a spellcaster
   * @param characterClass Character's class
   * @returns boolean
   */
  static isSpellcaster(characterClass) {
    return characterClass.name in this.spellcastingAbilities || characterClass.name.includes("Wizard") || characterClass.name.includes("Druid") || characterClass.name.includes("Bard");
  }
  /**
   * Generate spellcasting information
   * @param characterClass Character's class
   * @param abilityModifiers Ability modifiers
   * @param level Character level
   * @returns Spellcasting object or null
   */
  static generateSpellcasting(characterClass, abilityModifiers, level) {
    let spellcastingAbility = this.spellcastingAbilities[characterClass.name];
    if (!spellcastingAbility) {
      if (characterClass.name.includes("Wizard")) {
        spellcastingAbility = "int";
      } else if (characterClass.name.includes("Druid")) {
        spellcastingAbility = "wis";
      } else if (characterClass.name.includes("Bard")) {
        spellcastingAbility = "cha";
      } else {
        return null;
      }
    }
    const modifier = abilityModifiers[spellcastingAbility] || 0;
    const proficiencyBonus = Math.ceil(level / 4) + 1;
    const saveDC = 8 + proficiencyBonus + modifier;
    const attackBonus = proficiencyBonus + modifier;
    let cantripsKnown = 0;
    switch (characterClass.name) {
      case "Wizard":
      case "Chronurgy Wizard":
      case "Graviturgy Wizard":
        cantripsKnown = level < 4 ? 3 : level < 10 ? 4 : 5;
        break;
      case "Cleric":
        cantripsKnown = level < 4 ? 3 : level < 10 ? 4 : 5;
        break;
      case "Druid":
      case "Circle of Stars Druid":
        cantripsKnown = level < 4 ? 2 : level < 10 ? 3 : 4;
        break;
      case "Bard":
      case "College of Eloquence Bard":
        cantripsKnown = level < 4 ? 2 : level < 10 ? 3 : 4;
        break;
      case "Sorcerer":
        cantripsKnown = level < 4 ? 4 : level < 10 ? 5 : 6;
        break;
      case "Warlock":
        cantripsKnown = level < 4 ? 2 : level < 10 ? 3 : 4;
        break;
      case "Artificer":
        cantripsKnown = level < 10 ? 2 : 3;
        break;
      default:
        cantripsKnown = 2;
    }
    const slots = {};
    if (["Wizard", "Chronurgy Wizard", "Graviturgy Wizard", "Cleric", "Druid", "Circle of Stars Druid", "Bard", "College of Eloquence Bard", "Sorcerer"].includes(characterClass.name)) {
      this.calculateFullCasterSlots(level, slots);
    } else if (["Paladin", "Ranger"].includes(characterClass.name)) {
      this.calculateHalfCasterSlots(level, slots);
    } else if (["Artificer"].includes(characterClass.name)) {
      this.calculateHalfCasterSlots(Math.ceil(level / 2) * 2, slots);
    } else if (["Warlock"].includes(characterClass.name)) {
      this.calculateWarlockSlots(level, slots);
    }
    return {
      ability: spellcastingAbility.toUpperCase(),
      saveDC,
      attackBonus,
      cantripsKnown,
      slots
    };
  }
  /**
   * Calculate spell slots for full casters
   * @param level Character level
   * @param slots Slots object to populate
   */
  static calculateFullCasterSlots(level, slots) {
    if (level >= 1) {
      slots[1] = level === 1 ? 2 : level === 2 ? 3 : 4;
    }
    if (level >= 3) {
      slots[2] = level === 3 ? 2 : 3;
    }
    if (level >= 5) {
      slots[3] = level === 5 ? 2 : 3;
    }
    if (level >= 7) {
      slots[4] = level === 7 ? 1 : level <= 8 ? 2 : 3;
    }
    if (level >= 9) {
      slots[5] = level === 9 ? 1 : level <= 17 ? 2 : 3;
    }
    if (level >= 11) {
      slots[6] = level <= 18 ? 1 : 2;
    }
    if (level >= 13) {
      slots[7] = level <= 19 ? 1 : 2;
    }
    if (level >= 15) {
      slots[8] = 1;
    }
    if (level >= 17) {
      slots[9] = 1;
    }
  }
  /**
   * Calculate spell slots for half casters
   * @param level Character level
   * @param slots Slots object to populate
   */
  static calculateHalfCasterSlots(level, slots) {
    if (level >= 2) {
      slots[1] = level === 2 ? 2 : 3;
    }
    if (level >= 5) {
      slots[2] = level <= 6 ? 2 : 3;
    }
    if (level >= 9) {
      slots[3] = level <= 10 ? 2 : 3;
    }
    if (level >= 13) {
      slots[4] = level <= 14 ? 1 : level <= 16 ? 2 : 3;
    }
    if (level >= 17) {
      slots[5] = level <= 18 ? 1 : 2;
    }
  }
  /**
   * Calculate spell slots for warlocks
   * @param level Character level
   * @param slots Slots object to populate
   */
  static calculateWarlockSlots(level, slots) {
    const slotLevel = level <= 2 ? 1 : level <= 4 ? 2 : level <= 6 ? 3 : level <= 8 ? 4 : 5;
    const numSlots = level === 1 ? 1 : level <= 2 ? 2 : level <= 10 ? 2 : level <= 16 ? 3 : 4;
    slots[slotLevel] = numSlots;
  }
  /**
   * Get spells for a given class and spell level
   * @param className Class name
   * @param spellLevel Spell level
   * @returns Array of spell names
   */
  static getSpellsByClassAndLevel(className, spellLevel) {
    var _a;
    let baseClass = className;
    if (className.includes("Wizard")) {
      baseClass = "Wizard";
    } else if (className.includes("Druid")) {
      baseClass = "Druid";
    } else if (className.includes("Bard")) {
      baseClass = "Bard";
    }
    return ((_a = this.spellsByClassAndLevel[baseClass]) == null ? void 0 : _a[spellLevel]) || [];
  }
  /**
   * Get cantrips for a given class
   * @param className Class name
   * @returns Array of cantrip names
   */
  static getCantrips(className) {
    return this.cantrips[className] || [];
  }
};
/**
 * Spellcasting ability for different classes
 */
SpellcastingUtils.spellcastingAbilities = {
  "Wizard": "int",
  "Chronurgy Wizard": "int",
  "Graviturgy Wizard": "int",
  "Cleric": "wis",
  "Druid": "wis",
  "Circle of Stars Druid": "wis",
  "Bard": "cha",
  "College of Eloquence Bard": "cha",
  "Paladin": "cha",
  "Sorcerer": "cha",
  "Warlock": "cha",
  "Ranger": "wis",
  "Artificer": "int"
};
/**
 * Predefined spell lists by class and level
 */
SpellcastingUtils.spellsByClassAndLevel = {
  "Wizard": {
    1: ["alarm", "burning hands", "charm person", "color spray", "comprehend languages", "detect magic", "disguise self", "find familiar", "fog cloud", "grease", "identify", "mage armor", "magic missile", "shield", "silent image", "sleep", "thunderwave"],
    2: ["arcane lock", "blur", "darkness", "darkvision", "detect thoughts", "flaming sphere", "hold person", "invisibility", "knock", "levitate", "magic weapon", "mirror image", "misty step", "scorching ray", "see invisibility", "shatter", "spider climb", "web"],
    3: ["animate dead", "bestow curse", "blink", "clairvoyance", "counterspell", "dispel magic", "fireball", "fly", "gaseous form", "haste", "hypnotic pattern", "lightning bolt", "major image", "protection from energy", "slow", "stinking cloud", "tongues", "water breathing"],
    4: ["arcane eye", "banishment", "black tentacles", "blight", "confusion", "conjure minor elementals", "dimension door", "fabricate", "fire shield", "greater invisibility", "ice storm", "phantasmal killer", "polymorph", "stoneskin", "wall of fire"],
    5: ["animate objects", "bigby's hand", "cloudkill", "cone of cold", "creation", "dominate person", "hold monster", "legend lore", "mislead", "modify memory", "passwall", "scrying", "telekinesis", "teleportation circle", "wall of force", "wall of stone"],
    6: ["chain lightning", "circle of death", "contingency", "create undead", "disintegrate", "eyebite", "flesh to stone", "globe of invulnerability", "guards and wards", "magic jar", "mass suggestion", "move earth", "otiluke's freezing sphere", "programmed illusion", "true seeing"],
    7: ["delayed blast fireball", "etherealness", "finger of death", "forcecage", "mirage arcane", "mordenkainen's magnificent mansion", "mordenkainen's sword", "plane shift", "prismatic spray", "project image", "reverse gravity", "sequester", "simulacrum", "symbol", "teleport"],
    8: ["antimagic field", "clone", "control weather", "demiplane", "dominate monster", "feeblemind", "incendiary cloud", "maze", "mind blank", "power word stun", "sunburst"],
    9: ["astral projection", "foresight", "gate", "imprisonment", "meteor swarm", "power word kill", "prismatic wall", "shapechange", "time stop", "true polymorph", "weird", "wish"]
  },
  "Cleric": {
    1: ["bane", "bless", "command", "create or destroy water", "cure wounds", "detect evil and good", "detect magic", "detect poison and disease", "guiding bolt", "healing word", "inflict wounds", "protection from evil and good", "purify food and drink", "sanctuary", "shield of faith"],
    2: ["aid", "augury", "blindness/deafness", "calm emotions", "continual flame", "enhance ability", "find traps", "gentle repose", "hold person", "lesser restoration", "locate object", "prayer of healing", "protection from poison", "silence", "spiritual weapon", "warding bond", "zone of truth"],
    3: ["animate dead", "beacon of hope", "bestow curse", "clairvoyance", "create food and water", "daylight", "dispel magic", "glyph of warding", "magic circle", "mass healing word", "meld into stone", "protection from energy", "remove curse", "revivify", "sending", "speak with dead", "spirit guardians", "tongues", "water walk"],
    4: ["banishment", "control water", "death ward", "divination", "freedom of movement", "guardian of faith", "locate creature", "stone shape"],
    5: ["commune", "contagion", "dispel evil and good", "flame strike", "geas", "greater restoration", "hallow", "insect plague", "legend lore", "mass cure wounds", "planar binding", "raise dead", "scrying"],
    6: ["blade barrier", "create undead", "find the path", "forbiddance", "harm", "heal", "heroes' feast", "planar ally", "true seeing", "word of recall"],
    7: ["conjure celestial", "divine word", "etherealness", "fire storm", "plane shift", "regenerate", "resurrection", "symbol"],
    8: ["antimagic field", "control weather", "earthquake", "holy aura"],
    9: ["astral projection", "gate", "mass heal", "true resurrection"]
  },
  "Druid": {
    1: ["animal friendship", "charm person", "create or destroy water", "cure wounds", "detect magic", "detect poison and disease", "entangle", "faerie fire", "fog cloud", "goodberry", "healing word", "jump", "longstrider", "purify food and drink", "speak with animals", "thunderwave"],
    2: ["animal messenger", "barkskin", "darkvision", "enhance ability", "find traps", "flame blade", "flaming sphere", "gust of wind", "heat metal", "hold person", "lesser restoration", "locate animals or plants", "locate object", "moonbeam", "pass without trace", "protection from poison", "spike growth"],
    3: ["call lightning", "conjure animals", "daylight", "dispel magic", "meld into stone", "plant growth", "protection from energy", "sleet storm", "speak with plants", "water breathing", "water walk", "wind wall"],
    4: ["blight", "confusion", "conjure minor elementals", "conjure woodland beings", "control water", "dominate beast", "freedom of movement", "giant insect", "hallucinatory terrain", "ice storm", "locate creature", "polymorph", "stone shape", "stoneskin", "wall of fire"],
    5: ["antilife shell", "awaken", "commune with nature", "conjure elemental", "contagion", "geas", "greater restoration", "insect plague", "mass cure wounds", "planar binding", "reincarnate", "scrying", "tree stride", "wall of stone"],
    6: ["conjure fey", "find the path", "heal", "heroes' feast", "move earth", "sunbeam", "transport via plants", "wall of thorns", "wind walk"],
    7: ["fire storm", "mirage arcane", "plane shift", "regenerate", "reverse gravity"],
    8: ["animal shapes", "antipathy/sympathy", "control weather", "earthquake", "feeblemind", "sunburst"],
    9: ["foresight", "shapechange", "storm of vengeance", "true resurrection"]
  },
  "Bard": {
    1: ["animal friendship", "bane", "charm person", "comprehend languages", "cure wounds", "detect magic", "disguise self", "faerie fire", "feather fall", "healing word", "heroism", "hideous laughter", "identify", "illusory script", "longstrider", "silent image", "sleep", "speak with animals", "thunderwave", "unseen servant"],
    2: ["animal messenger", "blindness/deafness", "calm emotions", "cloud of daggers", "crown of madness", "detect thoughts", "enhance ability", "enthrall", "heat metal", "hold person", "invisibility", "knock", "lesser restoration", "locate animals or plants", "locate object", "magic mouth", "phantasmal force", "see invisibility", "shatter", "silence", "suggestion", "zone of truth"],
    3: ["bestow curse", "clairvoyance", "dispel magic", "fear", "feign death", "glyph of warding", "hypnotic pattern", "leomund's tiny hut", "major image", "nondetection", "plant growth", "sending", "speak with dead", "speak with plants", "stinking cloud", "tongues"],
    4: ["compulsion", "confusion", "dimension door", "freedom of movement", "greater invisibility", "hallucinatory terrain", "locate creature", "polymorph"],
    5: ["animate objects", "awaken", "dominate person", "dream", "geas", "greater restoration", "hold monster", "legend lore", "mass cure wounds", "mislead", "modify memory", "planar binding", "raise dead", "scrying", "seeming", "teleportation circle"],
    6: ["eyebite", "find the path", "guards and wards", "heroes' feast", "mass suggestion", "otto's irresistible dance", "programmed illusion", "true seeing"],
    7: ["etherealness", "forcecage", "mirage arcane", "mordenkainen's magnificent mansion", "mordenkainen's sword", "project image", "regenerate", "resurrection", "symbol", "teleport"],
    8: ["dominate monster", "feeblemind", "glibness", "mind blank", "power word stun"],
    9: ["foresight", "power word kill", "true polymorph"]
  },
  "Sorcerer": {
    1: ["burning hands", "charm person", "color spray", "comprehend languages", "detect magic", "disguise self", "expeditious retreat", "false life", "feather fall", "fog cloud", "jump", "mage armor", "magic missile", "ray of sickness", "shield", "silent image", "sleep", "thunderwave", "witch bolt"],
    2: ["alter self", "blindness/deafness", "blur", "darkness", "darkvision", "detect thoughts", "enhance ability", "enlarge/reduce", "gust of wind", "hold person", "invisibility", "knock", "levitate", "mirror image", "misty step", "scorching ray", "see invisibility", "shatter", "spider climb", "suggestion", "web"],
    3: ["blink", "clairvoyance", "counterspell", "daylight", "dispel magic", "fear", "fireball", "fly", "gaseous form", "haste", "hypnotic pattern", "lightning bolt", "major image", "protection from energy", "sleet storm", "slow", "stinking cloud", "tongues", "water breathing", "water walk"],
    4: ["banishment", "blight", "confusion", "dimension door", "dominate beast", "greater invisibility", "ice storm", "polymorph", "stoneskin", "wall of fire"],
    5: ["animate objects", "cloudkill", "cone of cold", "creation", "dominate person", "hold monster", "insect plague", "seeming", "telekinesis", "teleportation circle", "wall of stone"],
    6: ["chain lightning", "circle of death", "disintegrate", "eyebite", "globe of invulnerability", "mass suggestion", "move earth", "sunbeam", "true seeing"],
    7: ["delayed blast fireball", "etherealness", "finger of death", "fire storm", "plane shift", "prismatic spray", "reverse gravity", "teleport"],
    8: ["dominate monster", "earthquake", "incendiary cloud", "power word stun", "sunburst"],
    9: ["gate", "meteor swarm", "power word kill", "time stop", "wish"]
  },
  "Warlock": {
    1: ["armor of agathys", "arms of hadar", "charm person", "comprehend languages", "expeditious retreat", "hellish rebuke", "hex", "illusory script", "protection from evil and good", "unseen servant", "witch bolt"],
    2: ["cloud of daggers", "crown of madness", "darkness", "enthrall", "hold person", "invisibility", "mirror image", "misty step", "ray of enfeeblement", "shatter", "spider climb", "suggestion"],
    3: ["counterspell", "dispel magic", "fear", "fly", "gaseous form", "hunger of hadar", "hypnotic pattern", "magic circle", "major image", "remove curse", "tongues", "vampiric touch"],
    4: ["banishment", "blight", "dimension door", "hallucinatory terrain"],
    5: ["contact other plane", "dream", "hold monster", "scrying"],
    6: ["arcane gate", "circle of death", "conjure fey", "create undead", "eyebite", "flesh to stone", "mass suggestion", "true seeing"],
    7: ["etherealness", "finger of death", "forcecage", "plane shift"],
    8: ["demiplane", "dominate monster", "feeblemind", "glibness", "power word stun"],
    9: ["astral projection", "foresight", "imprisonment", "power word kill", "true polymorph"]
  },
  "Paladin": {
    1: ["bless", "command", "compelled duel", "cure wounds", "detect evil and good", "detect magic", "detect poison and disease", "divine favor", "heroism", "protection from evil and good", "purify food and drink", "shield of faith"],
    2: ["aid", "branding smite", "find steed", "lesser restoration", "locate object", "magic weapon", "protection from poison", "zone of truth"],
    3: ["aura of vitality", "blinding smite", "create food and water", "crusader's mantle", "daylight", "dispel magic", "elemental weapon", "magic circle", "remove curse", "revivify"],
    4: ["aura of life", "aura of purity", "banishment", "death ward", "locate creature", "staggering smite"],
    5: ["banishing smite", "circle of power", "destructive wave", "dispel evil and good", "geas", "raise dead"]
  },
  "Ranger": {
    1: ["alarm", "animal friendship", "cure wounds", "detect magic", "detect poison and disease", "fog cloud", "goodberry", "hunter's mark", "jump", "longstrider", "speak with animals"],
    2: ["animal messenger", "barkskin", "darkvision", "find traps", "lesser restoration", "locate animals or plants", "locate object", "pass without trace", "protection from poison", "silence", "spike growth"],
    3: ["conjure animals", "daylight", "nondetection", "plant growth", "protection from energy", "speak with plants", "water breathing", "water walk", "wind wall"],
    4: ["conjure woodland beings", "freedom of movement", "locate creature", "stoneskin"],
    5: ["commune with nature", "conjure volley", "swift quiver", "tree stride"]
  },
  "Artificer": {
    1: ["alarm", "cure wounds", "detect magic", "disguise self", "expeditious retreat", "faerie fire", "false life", "feather fall", "grease", "identify", "jump", "longstrider", "purify food and drink", "sanctuary", "shield of faith"],
    2: ["aid", "alter self", "arcane lock", "blur", "continual flame", "darkvision", "enhance ability", "enlarge/reduce", "heat metal", "invisibility", "lesser restoration", "levitate", "magic mouth", "magic weapon", "protection from poison", "rope trick", "see invisibility", "spider climb"],
    3: ["blink", "catnap", "create food and water", "dispel magic", "elemental weapon", "flame arrows", "fly", "glyph of warding", "haste", "protection from energy", "revivify", "tiny servant", "water breathing", "water walk"],
    4: ["arcane eye", "elemental bane", "fabricate", "freedom of movement", "leomund's secret chest", "mordenkainen's faithful hound", "mordenkainen's private sanctum", "otiluke's resilient sphere", "stone shape", "stoneskin"],
    5: ["animate objects", "bigby's hand", "creation", "greater restoration", "skill empowerment", "transmute rock", "wall of stone"]
  }
};
/**
 * Predefined cantrips by class
 */
SpellcastingUtils.cantrips = {
  "Wizard": ["acid splash", "chill touch", "dancing lights", "fire bolt", "light", "mage hand", "mending", "message", "minor illusion", "prestidigitation", "ray of frost", "shocking grasp"],
  "Chronurgy Wizard": ["acid splash", "chill touch", "dancing lights", "fire bolt", "light", "mage hand", "mending", "message", "minor illusion", "prestidigitation", "ray of frost", "shocking grasp"],
  "Graviturgy Wizard": ["acid splash", "chill touch", "dancing lights", "fire bolt", "light", "mage hand", "mending", "message", "minor illusion", "prestidigitation", "ray of frost", "shocking grasp"],
  "Sorcerer": ["acid splash", "chill touch", "dancing lights", "fire bolt", "light", "mage hand", "mending", "message", "minor illusion", "prestidigitation", "ray of frost", "shocking grasp", "true strike"],
  "Cleric": ["guidance", "light", "mending", "resistance", "sacred flame", "spare the dying", "thaumaturgy", "word of radiance"],
  "Druid": ["druidcraft", "guidance", "mending", "poison spray", "produce flame", "resistance", "shillelagh", "thorn whip"],
  "Circle of Stars Druid": ["druidcraft", "guidance", "mending", "poison spray", "produce flame", "resistance", "shillelagh", "thorn whip"],
  "Bard": ["dancing lights", "light", "mage hand", "mending", "message", "minor illusion", "prestidigitation", "true strike", "vicious mockery"],
  "College of Eloquence Bard": ["dancing lights", "light", "mage hand", "mending", "message", "minor illusion", "prestidigitation", "true strike", "vicious mockery"],
  "Warlock": ["chill touch", "eldritch blast", "mage hand", "minor illusion", "poison spray", "prestidigitation", "true strike"],
  "Artificer": ["acid splash", "fire bolt", "guidance", "light", "mage hand", "mending", "message", "prestidigitation", "ray of frost", "resistance", "shocking grasp", "spare the dying", "thorn whip"],
  "Ranger": ["druidcraft", "guidance", "mending", "produce flame", "resistance", "shillelagh"],
  "Paladin": ["light", "sacred flame", "spare the dying", "thaumaturgy"]
};

// src/ui/modal.ts
var import_obsidian = require("obsidian");
var NPCGeneratorModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.npc = null;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const modalContainer = contentEl.createDiv("npc-generator-container");
    modalContainer.addClass("npc-generator-container");
    const titleEl = modalContainer.createEl("h2", { text: "Generate NPC" });
    titleEl.style.borderBottom = "1px solid var(--background-modifier-border)";
    titleEl.style.paddingBottom = "10px";
    titleEl.style.marginBottom = "20px";
    const optionsContainer = modalContainer.createDiv("npc-generation-options");
    optionsContainer.style.display = "grid";
    optionsContainer.style.gridTemplateColumns = "1fr 1fr";
    optionsContainer.style.gap = "12px";
    optionsContainer.style.marginBottom = "20px";
    const levelContainer = this.createStyledInput(
      optionsContainer,
      "Level",
      "number",
      "1",
      { min: "1", max: "20" }
    );
    const levelInput = levelContainer.querySelector("input");
    const raceContainer = this.createStyledSelect(
      optionsContainer,
      "Race",
      this.plugin.settings.races.map((race) => race.name)
    );
    const raceSelect = raceContainer.querySelector("select");
    const classContainer = this.createStyledSelect(
      optionsContainer,
      "Class",
      this.plugin.settings.classes.map((characterClass) => characterClass.name)
    );
    const classSelect = classContainer.querySelector("select");
    const subclassContainer = this.createStyledSelect(
      optionsContainer,
      "Subclass",
      ["None"]
      // Default option
    );
    const subclassSelect = subclassContainer.querySelector("select");
    classSelect.addEventListener("change", () => {
      const selectedClass = this.plugin.settings.classes.find((c) => c.name === classSelect.value);
      while (subclassSelect.options.length > 1) {
        subclassSelect.remove(1);
      }
      if ((selectedClass == null ? void 0 : selectedClass.subclasses) && selectedClass.subclasses.length > 0) {
        subclassContainer.style.display = "block";
        selectedClass.subclasses.forEach((subclass) => {
          subclassSelect.add(new Option(subclass.name, subclass.name));
        });
      } else {
        subclassContainer.style.display = "none";
      }
    });
    classSelect.dispatchEvent(new Event("change"));
    const alignments = [
      "Lawful Good",
      "Neutral Good",
      "Chaotic Good",
      "Lawful Neutral",
      "Neutral",
      "Chaotic Neutral",
      "Lawful Evil",
      "Neutral Evil",
      "Chaotic Evil"
    ];
    const alignmentContainer = this.createStyledSelect(
      optionsContainer,
      "Alignment",
      alignments
    );
    const alignmentSelect = alignmentContainer.querySelector("select");
    const customParamsContainer = modalContainer.createDiv("custom-parameters");
    customParamsContainer.style.marginTop = "20px";
    customParamsContainer.style.marginBottom = "20px";
    const customParamsTitle = customParamsContainer.createEl("h3", { text: "Custom Parameters" });
    customParamsTitle.style.borderBottom = "1px solid var(--background-modifier-border)";
    customParamsTitle.style.paddingBottom = "8px";
    customParamsTitle.style.marginBottom = "12px";
    const enabledParams = this.plugin.settings.customParameters.filter((p) => p.enabled);
    if (enabledParams.length === 0) {
      customParamsContainer.createEl("p", {
        text: "No custom parameters enabled. Add parameters in plugin settings.",
        attr: { style: "color: var(--text-muted); font-style: italic; text-align: center; padding: 10px 0;" }
      });
    } else {
      const customParamsGrid = customParamsContainer.createDiv("custom-params-grid");
      customParamsGrid.style.display = "grid";
      customParamsGrid.style.gridTemplateColumns = "1fr 1fr";
      customParamsGrid.style.gap = "12px";
      enabledParams.forEach((param) => {
        if (["spellcasting", "possessions"].includes(param.name)) return;
        this.createStyledInput(
          customParamsGrid,
          param.label,
          "text",
          "",
          { placeholder: `Enter ${param.label.toLowerCase()}` }
        );
      });
    }
    const buttonContainer = modalContainer.createDiv("npc-generation-buttons");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "space-between";
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.paddingTop = "15px";
    buttonContainer.style.borderTop = "1px solid var(--background-modifier-border)";
    const generateButton = buttonContainer.createEl("button", {
      text: "Generate NPC",
      cls: "mod-cta"
    });
    generateButton.style.minWidth = "120px";
    generateButton.addEventListener("click", () => {
      const options = {
        level: parseInt(levelInput.value, 10),
        race: raceSelect.value,
        class: classSelect.value,
        subclass: subclassSelect.value,
        // Always include the subclass selection
        alignment: alignmentSelect.value,
        customParameters: {}
      };
      console.log(`Selected options: Level ${options.level}, Race ${options.race}, Class ${options.class}, Subclass ${options.subclass}`);
      enabledParams.forEach((param) => {
        if (["spellcasting", "possessions"].includes(param.name)) return;
        const input = customParamsContainer.querySelector(
          `input[placeholder="Enter ${param.label.toLowerCase()}"]`
        );
        if (input && input.value.trim()) {
          options.customParameters[param.name] = input.value.trim();
        }
      });
      try {
        this.npc = this.plugin.generateNPC(options);
        this.showResults();
      } catch (error) {
        console.error("NPC Generation Error:", error);
        new import_obsidian.Notice("Failed to generate NPC. Check console for details.");
      }
    });
    const randomButton = buttonContainer.createEl("button", { text: "Random NPC" });
    randomButton.style.minWidth = "120px";
    randomButton.addEventListener("click", () => {
      try {
        this.npc = this.plugin.generateNPC();
        this.showResults();
      } catch (error) {
        console.error("Random NPC Generation Error:", error);
        new import_obsidian.Notice("Failed to generate random NPC. Check console for details.");
      }
    });
  }
  /**
   * Create a styled input element
   */
  createStyledInput(container, label, type, defaultValue = "", additionalAttributes = {}) {
    const inputContainer = container.createDiv("labeled-input");
    inputContainer.style.display = "flex";
    inputContainer.style.flexDirection = "column";
    const labelEl = inputContainer.createEl("label", { text: label });
    labelEl.style.fontWeight = "bold";
    labelEl.style.marginBottom = "4px";
    const input = inputContainer.createEl("input", {
      type,
      value: defaultValue,
      ...additionalAttributes
    });
    input.style.backgroundColor = "var(--background-primary)";
    input.style.border = "1px solid var(--background-modifier-border)";
    input.style.borderRadius = "4px";
    input.style.padding = "6px 8px";
    return inputContainer;
  }
  /**
   * Create a styled select element
   */
  createStyledSelect(container, label, options) {
    const selectContainer = container.createDiv("labeled-select");
    selectContainer.style.display = "flex";
    selectContainer.style.flexDirection = "column";
    const labelEl = selectContainer.createEl("label", { text: label });
    labelEl.style.fontWeight = "bold";
    labelEl.style.marginBottom = "4px";
    const select = selectContainer.createEl("select");
    select.style.backgroundColor = "var(--background-primary)";
    select.style.border = "1px solid var(--background-modifier-border)";
    select.style.borderRadius = "4px";
    select.style.padding = "6px 8px";
    options.forEach((option) => {
      select.createEl("option", {
        text: option,
        value: option
      });
    });
    return selectContainer;
  }
  /**
   * Display generated NPC results
   */
  showResults() {
    if (!this.npc) return;
    const { contentEl } = this;
    contentEl.empty();
    const resultsContainer = contentEl.createDiv("npc-results-container");
    resultsContainer.style.padding = "0 10px";
    const headerContainer = resultsContainer.createDiv("npc-header");
    headerContainer.style.borderBottom = "2px solid var(--interactive-accent)";
    headerContainer.style.paddingBottom = "10px";
    headerContainer.style.marginBottom = "15px";
    const npcTitle = headerContainer.createEl("h2", {
      text: this.npc.name,
      cls: "npc-name"
    });
    npcTitle.style.margin = "0 0 5px 0";
    npcTitle.style.color = "var(--text-accent)";
    const npcSubtitle = headerContainer.createEl("div", {
      text: `Level ${this.npc.level} ${this.npc.race} ${this.npc.class} \u2022 ${this.npc.alignment}`,
      cls: "npc-subtitle"
    });
    npcSubtitle.style.fontSize = "1.1em";
    npcSubtitle.style.color = "var(--text-muted)";
    const abilitiesContainer = resultsContainer.createDiv("npc-abilities");
    abilitiesContainer.style.marginBottom = "20px";
    const abilitiesTitle = abilitiesContainer.createEl("h3", { text: "Ability Scores" });
    abilitiesTitle.style.marginBottom = "10px";
    abilitiesTitle.style.paddingBottom = "5px";
    abilitiesTitle.style.borderBottom = "1px solid var(--background-modifier-border)";
    const abilitiesGrid = abilitiesContainer.createDiv("abilities-grid");
    abilitiesGrid.style.display = "grid";
    abilitiesGrid.style.gridTemplateColumns = "repeat(6, 1fr)";
    abilitiesGrid.style.gap = "10px";
    abilitiesGrid.style.textAlign = "center";
    const abilities = [
      { name: "STR", key: "str" },
      { name: "DEX", key: "dex" },
      { name: "CON", key: "con" },
      { name: "INT", key: "int" },
      { name: "WIS", key: "wis" },
      { name: "CHA", key: "cha" }
    ];
    abilities.forEach((ability) => {
      const abilityBox = abilitiesGrid.createDiv("ability-box");
      abilityBox.style.padding = "8px";
      abilityBox.style.border = "1px solid var(--background-modifier-border)";
      abilityBox.style.borderRadius = "4px";
      abilityBox.style.backgroundColor = "var(--background-secondary)";
      const abilityName = abilityBox.createDiv("ability-name");
      abilityName.style.fontWeight = "bold";
      abilityName.style.marginBottom = "5px";
      abilityName.textContent = ability.name;
      const score = this.npc.abilityScores[ability.key];
      const modifier = this.npc.abilityModifiers[ability.key] || 0;
      const abilityScore = abilityBox.createDiv("ability-score");
      abilityScore.style.fontSize = "1.2em";
      abilityScore.textContent = score.toString();
      const abilityMod = abilityBox.createDiv("ability-mod");
      abilityMod.style.color = "var(--text-accent)";
      abilityMod.textContent = `${modifier >= 0 ? "+" : ""}${modifier}`;
    });
    const statblockContainer = resultsContainer.createDiv("npc-statblock");
    statblockContainer.style.marginBottom = "20px";
    const statblockTitle = statblockContainer.createEl("h3", { text: "Statblock" });
    statblockTitle.style.marginBottom = "10px";
    statblockTitle.style.paddingBottom = "5px";
    statblockTitle.style.borderBottom = "1px solid var(--background-modifier-border)";
    const statblockText = statblockContainer.createEl("textarea", {
      text: this.plugin.formatStatblock(this.npc)
    });
    statblockText.setAttribute("readonly", "true");
    statblockText.style.width = "100%";
    statblockText.style.height = "300px";
    statblockText.style.padding = "10px";
    statblockText.style.fontFamily = "var(--font-monospace)";
    statblockText.style.fontSize = "0.9em";
    statblockText.style.backgroundColor = "var(--background-secondary)";
    statblockText.style.border = "1px solid var(--background-modifier-border)";
    statblockText.style.borderRadius = "4px";
    statblockText.style.resize = "vertical";
    const buttonContainer = resultsContainer.createDiv("npc-action-buttons");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "space-between";
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.paddingTop = "15px";
    buttonContainer.style.borderTop = "1px solid var(--background-modifier-border)";
    const refreshButton = buttonContainer.createEl("button", { text: "Refresh NPC" });
    refreshButton.style.minWidth = "80px";
    refreshButton.addEventListener("click", () => {
      const options = {
        level: this.npc.level,
        race: this.npc.race,
        class: this.npc.class,
        subclass: this.npc.subclass,
        alignment: this.npc.alignment
      };
      this.npc = this.plugin.generateNPC(options);
      this.showResults();
    });
    const regenerateButton = buttonContainer.createEl("button", { text: "Random NPC" });
    regenerateButton.style.minWidth = "80px";
    regenerateButton.addEventListener("click", () => {
      this.npc = this.plugin.generateNPC();
      this.showResults();
    });
    const insertButton = buttonContainer.createEl("button", {
      text: "Insert into Current Note",
      cls: "mod-cta"
    });
    insertButton.style.minWidth = "140px";
    insertButton.addEventListener("click", this.insertStatblockIntoNote.bind(this));
    const backButton = buttonContainer.createEl("button", { text: "Generate Another NPC" });
    backButton.style.minWidth = "120px";
    backButton.addEventListener("click", () => this.onOpen());
  }
  /**
   * Insert statblock into the current active note
   */
  insertStatblockIntoNote() {
    if (!this.npc) return;
    try {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile) {
        throw new Error("No active file");
      }
      const activeEditor = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeEditor) {
        throw new Error("No active editor");
      }
      const editor = activeEditor.editor;
      editor.replaceSelection(this.plugin.formatStatblock(this.npc));
      this.close();
      new import_obsidian.Notice("NPC statblock inserted!");
    } catch (error) {
      console.error("Insert Statblock Error:", error);
      new import_obsidian.Notice("Failed to insert statblock. Please ensure a note is open.");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/settings-tab.ts
var import_obsidian2 = require("obsidian");
var NPCGeneratorSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.activeTab = "general";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "NPC Generator Settings" });
    const navContainer = containerEl.createDiv("nav-container");
    navContainer.style.display = "flex";
    navContainer.style.marginBottom = "20px";
    navContainer.style.borderBottom = "1px solid var(--background-modifier-border)";
    const createTab = (id, label) => {
      const tab = navContainer.createEl("button", { text: label });
      tab.style.padding = "8px 16px";
      tab.style.border = "none";
      tab.style.background = "none";
      tab.style.cursor = "pointer";
      tab.style.borderRadius = "4px 4px 0 0";
      tab.style.marginRight = "4px";
      if (id === this.activeTab) {
        tab.style.borderBottom = "2px solid var(--interactive-accent)";
        tab.style.fontWeight = "bold";
        tab.style.color = "var(--interactive-accent)";
      }
      tab.addEventListener("click", () => {
        this.activeTab = id;
        this.display();
      });
      return tab;
    };
    createTab("general", "General");
    createTab("races", "Races");
    createTab("classes", "Classes");
    createTab("parameters", "Custom Parameters");
    const contentContainer = containerEl.createDiv("content-container");
    contentContainer.style.maxHeight = "500px";
    contentContainer.style.overflowY = "auto";
    contentContainer.style.padding = "10px";
    contentContainer.style.border = "1px solid var(--background-modifier-border)";
    contentContainer.style.borderRadius = "4px";
    switch (this.activeTab) {
      case "general":
        this.addStatblockFormatSection(contentContainer);
        break;
      case "races":
        this.addRacesSection(contentContainer);
        break;
      case "classes":
        this.addClassesSection(contentContainer);
        break;
      case "parameters":
        this.addCustomParametersSection(contentContainer);
        break;
    }
  }
  /**
   * Add Statblock Format Selection
   */
  addStatblockFormatSection(contentEl) {
    const statblockSection = contentEl.createDiv("statblock-format-section");
    statblockSection.createEl("h2", { text: "Statblock Format" });
    statblockSection.createEl("p", {
      text: "Select how NPC statblocks should be formatted when inserted into your notes.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(statblockSection).setName("Choose Statblock Style").setDesc("Select the format for generated NPC statblocks").addDropdown((dropdown) => {
      dropdown.addOption("fantasyStatblock", "Fantasy Statblock").addOption("basic", "Basic Text").setValue(this.plugin.settings.statblockFormat).onChange(async (value) => {
        this.plugin.settings.statblockFormat = value;
        await this.plugin.saveSettings();
      });
    });
  }
  /**
   * Add Races Management Section
   */
  addRacesSection(contentEl) {
    const racesSection = contentEl.createDiv("races-section");
    const headerContainer = racesSection.createDiv("section-header");
    headerContainer.createEl("h2", { text: "Races" });
    headerContainer.createEl("p", {
      text: "Manage the available races for NPC generation.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(racesSection).setName("Add New Race").setDesc("Create a new playable race for NPC generation").addButton((button) => {
      return button.setButtonText("Add Race").setCta().onClick(() => this.openRaceModal());
    });
    const racesContainer = racesSection.createDiv("races-container");
    racesContainer.style.display = "grid";
    racesContainer.style.gridTemplateColumns = "repeat(auto-fill, minmax(250px, 1fr))";
    racesContainer.style.gap = "10px";
    racesContainer.style.marginTop = "20px";
    this.plugin.settings.races.forEach((race, index) => {
      const raceCard = racesContainer.createDiv("race-card");
      raceCard.style.border = "1px solid var(--background-modifier-border)";
      raceCard.style.borderRadius = "5px";
      raceCard.style.padding = "10px";
      raceCard.style.backgroundColor = "var(--background-secondary)";
      const raceHeader = raceCard.createDiv("race-header");
      raceHeader.style.borderBottom = "1px solid var(--background-modifier-border)";
      raceHeader.style.paddingBottom = "5px";
      raceHeader.style.marginBottom = "8px";
      raceHeader.createEl("h3", {
        text: race.name,
        attr: { style: "margin: 0; font-size: 1.1em;" }
      });
      const raceDescription = raceCard.createDiv("race-description");
      raceDescription.style.fontSize = "0.9em";
      raceDescription.style.marginBottom = "10px";
      raceDescription.style.color = "var(--text-muted)";
      raceDescription.textContent = this.formatRaceDescription(race);
      const raceActions = raceCard.createDiv("race-actions");
      raceActions.style.display = "flex";
      raceActions.style.justifyContent = "space-between";
      const editButton = raceActions.createEl("button", { text: "Edit" });
      editButton.style.padding = "4px 8px";
      editButton.style.fontSize = "0.8em";
      editButton.addEventListener("click", () => {
        this.openRaceModal(race, index);
      });
      const deleteButton = raceActions.createEl("button", { text: "Delete" });
      deleteButton.style.padding = "4px 8px";
      deleteButton.style.fontSize = "0.8em";
      deleteButton.style.color = "var(--text-error)";
      deleteButton.addEventListener("click", async () => {
        if (confirm(`Are you sure you want to delete the ${race.name} race?`)) {
          this.plugin.settings.races.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
        }
      });
    });
  }
  /**
   * Add Classes Management Section
   */
  addClassesSection(contentEl) {
    const classesSection = contentEl.createDiv("classes-section");
    const headerContainer = classesSection.createDiv("section-header");
    headerContainer.createEl("h2", { text: "Classes" });
    headerContainer.createEl("p", {
      text: "Manage the available classes and subclasses for NPC generation.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(classesSection).setName("Add New Class").setDesc("Create a new character class for NPC generation").addButton((button) => {
      return button.setButtonText("Add Class").setCta().onClick(() => this.openClassModal());
    });
    const classesContainer = classesSection.createDiv("classes-container");
    classesContainer.style.marginTop = "15px";
    this.plugin.settings.classes.forEach((characterClass, index) => {
      const classItem = classesContainer.createDiv("class-item");
      classItem.style.marginBottom = "10px";
      classItem.style.border = "1px solid var(--background-modifier-border)";
      classItem.style.borderRadius = "5px";
      classItem.style.overflow = "hidden";
      const classHeader = classItem.createDiv("class-header");
      classHeader.style.padding = "10px";
      classHeader.style.backgroundColor = "var(--background-secondary)";
      classHeader.style.cursor = "pointer";
      classHeader.style.display = "flex";
      classHeader.style.justifyContent = "space-between";
      classHeader.style.alignItems = "center";
      const classTitle = classHeader.createDiv("class-title");
      classTitle.style.fontWeight = "bold";
      classTitle.textContent = characterClass.name;
      const classSummary = classHeader.createDiv("class-summary");
      classSummary.style.fontSize = "0.9em";
      classSummary.style.color = "var(--text-muted)";
      classSummary.textContent = this.formatClassDescription(characterClass);
      const expandIcon = classHeader.createDiv("expand-icon");
      expandIcon.textContent = "\u25BC";
      expandIcon.style.marginLeft = "10px";
      const classDetails = classItem.createDiv("class-details");
      classDetails.style.padding = "10px";
      classDetails.style.borderTop = "1px solid var(--background-modifier-border)";
      classDetails.style.display = "none";
      const featuresSection = classDetails.createDiv("features-section");
      featuresSection.style.marginBottom = "10px";
      featuresSection.createEl("h4", {
        text: "Class Features",
        attr: { style: "margin: 0 0 5px 0; font-size: 1em;" }
      });
      if (characterClass.features && characterClass.features.length > 0) {
        const featuresList = featuresSection.createEl("ul");
        featuresList.style.margin = "0";
        featuresList.style.paddingLeft = "20px";
        characterClass.features.forEach((feature) => {
          const featureItem = featuresList.createEl("li");
          featureItem.style.fontSize = "0.9em";
          featureItem.textContent = `Level ${feature.level}: ${feature.name}`;
        });
      } else {
        featuresSection.createEl("p", {
          text: "No features defined.",
          attr: { style: "color: var(--text-muted); font-style: italic; margin: 0;" }
        });
      }
      const subclassesSection = classDetails.createDiv("subclasses-section");
      const subclassHeader = subclassesSection.createDiv("subclass-header");
      subclassHeader.style.display = "flex";
      subclassHeader.style.justifyContent = "space-between";
      subclassHeader.style.alignItems = "center";
      subclassHeader.style.marginBottom = "5px";
      subclassHeader.createEl("h4", {
        text: "Subclasses",
        attr: { style: "margin: 0; font-size: 1em;" }
      });
      const addSubclassButton = subclassHeader.createEl("button", { text: "Add Subclass" });
      addSubclassButton.style.fontSize = "0.8em";
      addSubclassButton.style.padding = "2px 6px";
      addSubclassButton.addEventListener("click", () => {
        this.openSubclassModal(characterClass, index);
      });
      if (characterClass.subclasses && characterClass.subclasses.length > 0) {
        const subclassesList = subclassesSection.createEl("ul");
        subclassesList.style.margin = "0";
        subclassesList.style.paddingLeft = "20px";
        characterClass.subclasses.forEach((subclass, subclassIndex) => {
          const subclassItem = subclassesList.createEl("li");
          subclassItem.style.fontSize = "0.9em";
          subclassItem.style.marginBottom = "5px";
          const subclassText = subclassItem.createSpan();
          subclassText.textContent = subclass.name;
          const subclassActions = subclassItem.createSpan();
          subclassActions.style.marginLeft = "10px";
          const editSubclassButton = subclassActions.createEl("button", { text: "Edit" });
          editSubclassButton.style.fontSize = "0.7em";
          editSubclassButton.style.padding = "2px 4px";
          editSubclassButton.style.marginRight = "5px";
          editSubclassButton.addEventListener("click", () => {
            this.openSubclassModal(characterClass, index, subclass, subclassIndex);
          });
          const deleteSubclassButton = subclassActions.createEl("button", { text: "Delete" });
          deleteSubclassButton.style.fontSize = "0.7em";
          deleteSubclassButton.style.padding = "2px 4px";
          deleteSubclassButton.style.color = "var(--text-error)";
          deleteSubclassButton.addEventListener("click", async () => {
            var _a;
            if (confirm(`Are you sure you want to delete the ${subclass.name} subclass?`)) {
              (_a = characterClass.subclasses) == null ? void 0 : _a.splice(subclassIndex, 1);
              await this.plugin.saveSettings();
              this.display();
            }
          });
        });
      } else {
        subclassesSection.createEl("p", {
          text: "No subclasses defined.",
          attr: { style: "color: var(--text-muted); font-style: italic; margin: 0;" }
        });
      }
      const classActions = classDetails.createDiv("class-actions");
      classActions.style.display = "flex";
      classActions.style.justifyContent = "flex-end";
      classActions.style.marginTop = "10px";
      classActions.style.borderTop = "1px solid var(--background-modifier-border)";
      classActions.style.paddingTop = "10px";
      const editButton = classActions.createEl("button", { text: "Edit Class" });
      editButton.style.marginRight = "10px";
      editButton.addEventListener("click", () => {
        this.openClassModal(characterClass, index);
      });
      const deleteButton = classActions.createEl("button", { text: "Delete Class" });
      deleteButton.style.color = "var(--text-error)";
      deleteButton.addEventListener("click", async () => {
        if (confirm(`Are you sure you want to delete the ${characterClass.name} class?`)) {
          this.plugin.settings.classes.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
        }
      });
      classHeader.addEventListener("click", () => {
        const expanded = classDetails.style.display !== "none";
        classDetails.style.display = expanded ? "none" : "block";
        expandIcon.textContent = expanded ? "\u25BC" : "\u25B2";
      });
    });
  }
  /**
   * Add Custom Parameters Management Section
   */
  addCustomParametersSection(contentEl) {
    const customParamsSection = contentEl.createDiv("custom-parameters-section");
    const headerContainer = customParamsSection.createDiv("section-header");
    headerContainer.createEl("h2", { text: "Custom Parameters" });
    headerContainer.createEl("p", {
      text: "Add custom fields to your NPC generation form and statblocks.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(customParamsSection).setName("Add Custom Parameter").setDesc("Create a new custom parameter for NPC generation").addButton((button) => {
      return button.setButtonText("Add Parameter").setCta().onClick(() => this.openCustomParameterModal());
    });
    const customParams = this.plugin.settings.customParameters.filter(
      (param) => param.name !== "spellcasting" && param.name !== "possessions"
    );
    const paramsContainer = customParamsSection.createDiv("params-container");
    paramsContainer.style.marginTop = "20px";
    if (customParams.length === 0) {
      paramsContainer.createEl("p", {
        text: "No custom parameters defined.",
        attr: { style: "color: var(--text-muted); font-style: italic; text-align: center; padding: 20px;" }
      });
    } else {
      const paramTable = paramsContainer.createEl("table");
      paramTable.style.width = "100%";
      paramTable.style.borderCollapse = "collapse";
      const thead = paramTable.createEl("thead");
      const headerRow = thead.createEl("tr");
      headerRow.style.backgroundColor = "var(--background-secondary)";
      ["Parameter", "Format", "Enabled", "Actions"].forEach((heading) => {
        const th = headerRow.createEl("th");
        th.style.padding = "8px";
        th.style.textAlign = "left";
        th.style.borderBottom = "1px solid var(--background-modifier-border)";
        th.textContent = heading;
      });
      const tbody = paramTable.createEl("tbody");
      customParams.forEach((param) => {
        const row = tbody.createEl("tr");
        row.style.borderBottom = "1px solid var(--background-modifier-border)";
        const nameCell = row.createEl("td");
        nameCell.style.padding = "8px";
        const paramName = nameCell.createEl("div", { text: param.label });
        paramName.style.fontWeight = "bold";
        const paramId = nameCell.createEl("div", { text: param.name });
        paramId.style.fontSize = "0.8em";
        paramId.style.color = "var(--text-muted)";
        const formatCell = row.createEl("td");
        formatCell.style.padding = "8px";
        formatCell.style.fontFamily = "var(--font-monospace)";
        formatCell.style.fontSize = "0.9em";
        formatCell.textContent = param.format;
        const enabledCell = row.createEl("td");
        enabledCell.style.padding = "8px";
        const toggle = document.createElement("input");
        toggle.type = "checkbox";
        toggle.checked = param.enabled;
        toggle.addEventListener("change", async () => {
          param.enabled = toggle.checked;
          await this.plugin.saveSettings();
        });
        enabledCell.appendChild(toggle);
        const actionsCell = row.createEl("td");
        actionsCell.style.padding = "8px";
        const editButton = actionsCell.createEl("button", { text: "Edit" });
        editButton.style.marginRight = "8px";
        editButton.style.padding = "4px 8px";
        editButton.style.fontSize = "0.8em";
        editButton.addEventListener("click", () => {
          this.openCustomParameterModal(param);
        });
        const deleteButton = actionsCell.createEl("button", { text: "Delete" });
        deleteButton.style.padding = "4px 8px";
        deleteButton.style.fontSize = "0.8em";
        deleteButton.style.color = "var(--text-error)";
        deleteButton.addEventListener("click", async () => {
          if (confirm(`Are you sure you want to delete the ${param.label} parameter?`)) {
            this.plugin.settings.customParameters.splice(
              this.plugin.settings.customParameters.indexOf(param),
              1
            );
            await this.plugin.saveSettings();
            this.display();
          }
        });
      });
    }
  }
  /**
   * Open Subclass Modal for Adding/Editing
   */
  openSubclassModal(characterClass, classIndex, existingSubclass, subclassIndex) {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText(existingSubclass ? `Edit ${existingSubclass.name} Subclass` : `Add New Subclass for ${characterClass.name}`);
    modal.contentEl.style.width = "500px";
    new import_obsidian2.Setting(modal.contentEl).setName("Subclass Name").addText((text) => {
      text.setValue((existingSubclass == null ? void 0 : existingSubclass.name) || "").setPlaceholder("Enter subclass name").onChange((value) => {
        if (existingSubclass) existingSubclass.name = value;
      });
    });
    new import_obsidian2.Setting(modal.contentEl).setName("Description").setDesc("Brief description of the subclass and its strengths").addTextArea((text) => {
      text.setValue((existingSubclass == null ? void 0 : existingSubclass.description) || "").setPlaceholder("Description of the subclass...").onChange((value) => {
        if (existingSubclass) existingSubclass.description = value;
      });
      const textEl = text.inputEl;
      textEl.style.width = "100%";
      textEl.style.height = "100px";
    });
    const featuresContainer = modal.contentEl.createDiv("subclass-features");
    featuresContainer.createEl("h3", { text: "Subclass Features" });
    featuresContainer.style.marginTop = "20px";
    const featuresList = featuresContainer.createDiv("features-list");
    const addFeatureRow = (feature) => {
      var _a;
      const featureRow = featuresList.createDiv("feature-row");
      featureRow.style.display = "flex";
      featureRow.style.marginBottom = "10px";
      featureRow.style.gap = "10px";
      const levelInput = document.createElement("input");
      levelInput.type = "number";
      levelInput.min = "1";
      levelInput.max = "20";
      levelInput.value = ((_a = feature == null ? void 0 : feature.level) == null ? void 0 : _a.toString()) || "3";
      levelInput.style.width = "60px";
      levelInput.placeholder = "Level";
      featureRow.appendChild(levelInput);
      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.value = (feature == null ? void 0 : feature.name) || "";
      nameInput.style.flex = "1";
      nameInput.placeholder = "Feature name";
      featureRow.appendChild(nameInput);
      const descInput = document.createElement("input");
      descInput.type = "text";
      descInput.value = (feature == null ? void 0 : feature.description) || "";
      descInput.style.flex = "2";
      descInput.placeholder = "Feature description";
      featureRow.appendChild(descInput);
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "\xD7";
      deleteBtn.style.color = "var(--text-error)";
      deleteBtn.addEventListener("click", () => {
        featureRow.remove();
      });
      featureRow.appendChild(deleteBtn);
      return { row: featureRow, levelInput, nameInput, descInput };
    };
    if ((existingSubclass == null ? void 0 : existingSubclass.features) && existingSubclass.features.length > 0) {
      existingSubclass.features.forEach((feature) => {
        addFeatureRow(feature);
      });
    } else {
      addFeatureRow();
    }
    const addFeatureButton = featuresContainer.createEl("button", { text: "Add Feature" });
    addFeatureButton.style.marginTop = "10px";
    addFeatureButton.addEventListener("click", () => {
      addFeatureRow();
    });
    const buttonContainer = modal.contentEl.createDiv("button-container");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.gap = "10px";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      modal.close();
    });
    const saveButton = buttonContainer.createEl("button", {
      text: "Save Subclass",
      cls: "mod-cta"
    });
    saveButton.addEventListener("click", async () => {
      const nameInput = modal.contentEl.querySelector('input[placeholder="Enter subclass name"]');
      const descriptionInput = modal.contentEl.querySelector('textarea[placeholder="Description of the subclass..."]');
      if (!nameInput.value.trim()) {
        new import_obsidian2.Notice("Subclass name is required");
        return;
      }
      const features = [];
      const featureRows = featuresList.querySelectorAll(".feature-row");
      featureRows.forEach((row) => {
        const inputs = row.querySelectorAll("input");
        if (inputs[1].value.trim()) {
          features.push({
            level: parseInt(inputs[0].value, 10) || 3,
            name: inputs[1].value.trim(),
            description: inputs[2].value.trim() || "No description provided."
          });
        }
      });
      features.sort((a, b) => a.level - b.level);
      const subclass = {
        name: nameInput.value.trim(),
        description: descriptionInput.value.trim() || "No description provided.",
        features
      };
      if (!characterClass.subclasses) {
        characterClass.subclasses = [];
      }
      if (existingSubclass && subclassIndex !== void 0) {
        characterClass.subclasses[subclassIndex] = subclass;
      } else {
        characterClass.subclasses.push(subclass);
      }
      this.plugin.settings.classes[classIndex] = characterClass;
      await this.plugin.saveSettings();
      this.display();
      modal.close();
    });
    modal.open();
  }
  /**
   * Open Race Modal for Adding/Editing
   */
  openRaceModal(existingRace, index) {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText(existingRace ? `Edit ${existingRace.name} Race` : "Add New Race");
    new import_obsidian2.Setting(modal.contentEl).setName("Race Name").addText((text) => {
      text.setValue((existingRace == null ? void 0 : existingRace.name) || "").onChange((value) => {
        if (existingRace) existingRace.name = value;
      });
    });
    const abilities = ["str", "dex", "con", "int", "wis", "cha"];
    abilities.forEach((ability) => {
      new import_obsidian2.Setting(modal.contentEl).setName(`${ability.toUpperCase()} Adjustment`).addSlider((slider) => {
        slider.setLimits(-2, 2, 1).setValue((existingRace == null ? void 0 : existingRace.abilityScoreAdjustments[ability]) || 0).setDynamicTooltip().onChange((value) => {
          if (existingRace) {
            existingRace.abilityScoreAdjustments[ability] = value;
          }
        });
      });
    });
    const traitsContainer = modal.contentEl.createDiv("race-traits");
    traitsContainer.createEl("h3", { text: "Racial Traits" });
    const traitsList = traitsContainer.createEl("ul");
    ((existingRace == null ? void 0 : existingRace.traits) || []).forEach((trait, traitIndex) => {
      const traitItem = traitsList.createEl("li");
      traitItem.createEl("span", { text: trait });
      traitItem.createEl("button", {
        text: "\xD7",
        attr: { style: "margin-left: 10px; color: var(--text-error);" }
      }).addEventListener("click", () => {
        if (existingRace) {
          existingRace.traits.splice(traitIndex, 1);
          traitItem.remove();
        }
      });
    });
    const newTraitContainer = modal.contentEl.createDiv("new-trait-input");
    newTraitContainer.style.display = "flex";
    newTraitContainer.style.gap = "10px";
    newTraitContainer.style.marginTop = "10px";
    const traitInput = newTraitContainer.createEl("input", {
      type: "text",
      placeholder: "Add a new trait"
    });
    traitInput.style.flex = "1";
    const addTraitButton = newTraitContainer.createEl("button", { text: "Add Trait" });
    addTraitButton.addEventListener("click", () => {
      const newTrait = traitInput.value.trim();
      if (newTrait) {
        if (!existingRace) {
          existingRace = {
            name: "",
            abilityScoreAdjustments: { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 },
            traits: [],
            size: "Medium",
            speed: 30,
            languages: ["Common"]
          };
        }
        existingRace.traits.push(newTrait);
        const traitItem = traitsList.createEl("li");
        traitItem.createEl("span", { text: newTrait });
        traitItem.createEl("button", {
          text: "\xD7",
          attr: { style: "margin-left: 10px; color: var(--text-error);" }
        }).addEventListener("click", () => {
          existingRace.traits.splice(existingRace.traits.length - 1, 1);
          traitItem.remove();
        });
        traitInput.value = "";
      }
    });
    new import_obsidian2.Setting(modal.contentEl).setName("Size").addDropdown((dropdown) => {
      dropdown.addOption("Small", "Small").addOption("Medium", "Medium").addOption("Large", "Large").setValue((existingRace == null ? void 0 : existingRace.size) || "Medium").onChange((value) => {
        if (existingRace) existingRace.size = value;
      });
    });
    new import_obsidian2.Setting(modal.contentEl).setName("Speed").addSlider((slider) => {
      slider.setLimits(20, 40, 5).setValue((existingRace == null ? void 0 : existingRace.speed) || 30).setDynamicTooltip().onChange((value) => {
        if (existingRace) existingRace.speed = value;
      });
    });
    const languagesContainer = modal.contentEl.createDiv("race-languages");
    languagesContainer.createEl("h3", { text: "Languages" });
    const commonLanguages = [
      "Common",
      "Dwarvish",
      "Elvish",
      "Giant",
      "Gnomish",
      "Goblin",
      "Halfling",
      "Orc",
      "Abyssal",
      "Celestial",
      "Draconic",
      "Deep Speech",
      "Infernal",
      "Primordial",
      "Sylvan",
      "Undercommon"
    ];
    const languagesList = languagesContainer.createDiv("languages-list");
    languagesList.style.display = "grid";
    languagesList.style.gridTemplateColumns = "repeat(3, 1fr)";
    languagesList.style.gap = "5px";
    commonLanguages.forEach((language) => {
      const languageCheck = languagesList.createDiv("language-check");
      languageCheck.style.display = "flex";
      languageCheck.style.alignItems = "center";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = (existingRace == null ? void 0 : existingRace.languages.includes(language)) || false;
      checkbox.id = `lang-${language}`;
      languageCheck.appendChild(checkbox);
      const label = document.createElement("label");
      label.textContent = language;
      label.htmlFor = `lang-${language}`;
      label.style.marginLeft = "5px";
      languageCheck.appendChild(label);
    });
    const buttonContainer = modal.contentEl.createDiv("button-container");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.gap = "10px";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      modal.close();
    });
    const saveButton = buttonContainer.createEl("button", {
      text: "Save Race",
      cls: "mod-cta"
    });
    saveButton.addEventListener("click", async () => {
      if (!existingRace || !existingRace.name) {
        new import_obsidian2.Notice("Race name is required");
        return;
      }
      const selectedLanguages = [];
      commonLanguages.forEach((language) => {
        const checkbox = document.getElementById(`lang-${language}`);
        if (checkbox && checkbox.checked) {
          selectedLanguages.push(language);
        }
      });
      if (selectedLanguages.length === 0) {
        selectedLanguages.push("Common");
      }
      existingRace.languages = selectedLanguages;
      if (index !== void 0) {
        this.plugin.settings.races[index] = existingRace;
      } else {
        this.plugin.settings.races.push(existingRace);
      }
      await this.plugin.saveSettings();
      this.display();
      modal.close();
    });
    modal.open();
  }
  /**
   * Open Class Modal for Adding/Editing
   */
  openClassModal(existingClass, index) {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText(existingClass ? `Edit ${existingClass.name} Class` : "Add New Class");
    modal.contentEl.style.width = "100%";
    modal.contentEl.style.maxWidth = "1000px";
    modal.contentEl.style.margin = "0 auto";
    modal.contentEl.style.padding = "0 20px";
    modal.contentEl.style.boxSizing = "border-box";
    const modalScrollContainer = modal.contentEl.createDiv("modal-scroll-container");
    modalScrollContainer.style.maxHeight = "80vh";
    modalScrollContainer.style.overflowY = "auto";
    modalScrollContainer.style.overflowX = "hidden";
    const basicRow = modalScrollContainer.createDiv("basic-class-info-row");
    basicRow.style.display = "flex";
    basicRow.style.flexWrap = "wrap";
    basicRow.style.gap = "10px";
    basicRow.style.marginBottom = "20px";
    const nameContainer = basicRow.createDiv("class-name-container");
    nameContainer.style.flex = "1";
    nameContainer.style.minWidth = "200px";
    const formContainer = basicRow.createDiv("class-form-container");
    formContainer.style.display = "grid";
    formContainer.style.gap = "15px";
    new import_obsidian2.Setting(nameContainer).setName("Class Name").addText((text) => {
      text.setValue((existingClass == null ? void 0 : existingClass.name) || "").setPlaceholder("Enter class name").onChange((value) => {
        if (existingClass) existingClass.name = value;
      });
      text.inputEl.style.width = "100%";
    });
    const detailsContainer = basicRow.createDiv("class-details-container");
    detailsContainer.style.display = "grid";
    detailsContainer.style.gridTemplateColumns = "1fr 1fr";
    detailsContainer.style.gap = "15px";
    const hitDieContainer = detailsContainer.createDiv("hit-die-container");
    new import_obsidian2.Setting(hitDieContainer).setName("Hit Die").addDropdown((dropdown) => {
      dropdown.addOption("6", "d6").addOption("8", "d8").addOption("10", "d10").addOption("12", "d12").setValue(((existingClass == null ? void 0 : existingClass.hitDie) || 8).toString()).onChange((value) => {
        if (existingClass) existingClass.hitDie = parseInt(value);
      });
    });
    const abilityContainer = detailsContainer.createDiv("ability-container");
    new import_obsidian2.Setting(abilityContainer).setName("Primary Ability").addDropdown((dropdown) => {
      dropdown.addOption("str", "STR").addOption("dex", "DEX").addOption("con", "CON").addOption("int", "INT").addOption("wis", "WIS").addOption("cha", "CHA").setValue((existingClass == null ? void 0 : existingClass.primaryAbility) || "str").onChange((value) => {
        if (existingClass) existingClass.primaryAbility = value;
      });
    });
    const spellcastingContainer = basicRow.createDiv("spellcasting-container");
    const spellcasterCheck = spellcastingContainer.createEl("div", { cls: "setting-item" });
    spellcasterCheck.style.display = "flex";
    spellcasterCheck.style.justifyContent = "space-between";
    spellcasterCheck.style.alignItems = "center";
    const spellcasterLabel = spellcasterCheck.createEl("label", { text: "Spellcasting" });
    spellcasterLabel.style.fontWeight = "normal";
    const checkboxContainer = spellcasterCheck.createEl("div");
    const checkbox = checkboxContainer.createEl("input", { type: "checkbox" });
    checkbox.checked = !!(existingClass == null ? void 0 : existingClass.spellcasting);
    checkbox.addEventListener("change", () => {
      if (existingClass) {
        if (checkbox.checked) {
          existingClass.spellcasting = {
            ability: "int",
            // default
            prepareSpells: false
          };
        } else {
          delete existingClass.spellcasting;
        }
      }
    });
    const classTabsContainer = modalScrollContainer.createDiv("class-tabs");
    classTabsContainer.style.display = "flex";
    classTabsContainer.style.flexWrap = "wrap";
    classTabsContainer.style.gap = "5px";
    classTabsContainer.style.marginBottom = "10px";
    classTabsContainer.style.borderBottom = "1px solid var(--background-modifier-border)";
    classTabsContainer.style.paddingBottom = "10px";
    let activeClassTab = "saves";
    const classTabContent = modalScrollContainer.createDiv("class-tab-content");
    classTabContent.style.padding = "15px 0";
    classTabContent.style.minHeight = "300px";
    const showClassTab = (tabId) => {
      activeClassTab = tabId;
      const tabs = classTabsContainer.querySelectorAll("button");
      tabs.forEach((tab) => {
        if (tab.id === `tab-${tabId}`) {
          tab.style.borderBottom = "2px solid var(--interactive-accent)";
          tab.style.color = "var(--interactive-accent)";
          tab.style.fontWeight = "bold";
        } else {
          tab.style.borderBottom = "none";
          tab.style.color = "var(--text-normal)";
          tab.style.fontWeight = "normal";
        }
      });
      classTabContent.empty();
      switch (tabId) {
        case "saves":
          this.renderSavingThrowsTab(classTabContent, existingClass);
          break;
        case "skills":
          this.renderSkillsTab(classTabContent, existingClass);
          break;
        case "features":
          this.renderFeaturesTab(classTabContent, existingClass);
          break;
        case "proficiencies":
          this.renderProficienciesTab(classTabContent, existingClass);
          break;
      }
    };
    const createClassTab = (id, label) => {
      const tab = classTabsContainer.createEl("button", {
        text: label,
        attr: { id: `tab-${id}` }
      });
      tab.style.padding = "8px 16px";
      tab.style.border = "none";
      tab.style.borderRadius = "4px";
      tab.style.background = "var(--background-secondary)";
      tab.style.cursor = "pointer";
      if (id === activeClassTab) {
        tab.style.borderBottom = "2px solid var(--interactive-accent)";
        tab.style.color = "var(--interactive-accent)";
        tab.style.fontWeight = "bold";
      }
      tab.addEventListener("click", () => {
        showClassTab(id);
      });
    };
    createClassTab("saves", "Saving Throws");
    createClassTab("skills", "Skills");
    createClassTab("features", "Features");
    createClassTab("proficiencies", "Proficiencies");
    showClassTab("saves");
    const buttonContainer = modal.contentEl.createDiv("button-container");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.margin = "20px 0 10px 0";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.padding = "10px 20px";
    buttonContainer.style.borderTop = "1px solid var(--background-modifier-border)";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.style.minWidth = "80px";
    cancelButton.addEventListener("click", () => {
      modal.close();
    });
    const saveButton = buttonContainer.createEl("button", {
      text: "Save Class",
      cls: "mod-cta"
    });
    saveButton.style.minWidth = "120px";
    saveButton.addEventListener("click", async () => {
      const nameInput = nameContainer.querySelector('input[placeholder="Class name"]');
      if (!nameInput || !nameInput.value.trim()) {
        new import_obsidian2.Notice("Class name is required");
        return;
      }
      if (!existingClass) {
        existingClass = {
          name: nameInput.value.trim(),
          hitDie: 8,
          primaryAbility: "str",
          savingThrows: ["str", "con"],
          skills: [],
          skillChoices: 2,
          proficiencies: {
            weapons: [],
            armor: [],
            tools: []
          },
          features: []
        };
      }
      existingClass.savingThrows = [];
      const abilities = ["str", "dex", "con", "int", "wis", "cha"];
      abilities.forEach((ability) => {
        const checkbox2 = modalScrollContainer.querySelector(`#save-${ability}`);
        if (checkbox2 && checkbox2.checked) {
          existingClass.savingThrows.push(ability);
        }
      });
      existingClass.skills = [];
      const allSkills = [
        "Acrobatics",
        "Animal Handling",
        "Arcana",
        "Athletics",
        "Deception",
        "History",
        "Insight",
        "Intimidation",
        "Investigation",
        "Medicine",
        "Nature",
        "Perception",
        "Performance",
        "Persuasion",
        "Religion",
        "Sleight of Hand",
        "Stealth",
        "Survival"
      ];
      allSkills.forEach((skill) => {
        const checkbox2 = modalScrollContainer.querySelector(`#skill-${skill}`);
        if (checkbox2 && checkbox2.checked) {
          existingClass.skills.push(skill);
        }
      });
      const skillChoicesInput = modalScrollContainer.querySelector("#skill-choices");
      if (skillChoicesInput) {
        existingClass.skillChoices = parseInt(skillChoicesInput.value, 10) || 2;
      }
      existingClass.features = [];
      const featureRows = modalScrollContainer.querySelectorAll(".feature-row");
      featureRows.forEach((row) => {
        const inputs = row.querySelectorAll("input");
        if (inputs.length >= 3 && inputs[1].value.trim()) {
          existingClass.features.push({
            level: parseInt(inputs[0].value, 10) || 1,
            name: inputs[1].value.trim(),
            description: inputs[2].value.trim() || "No description provided."
          });
        }
      });
      existingClass.proficiencies.weapons = [];
      const weaponsInputs = modalScrollContainer.querySelectorAll('input[name="weapon-prof"]');
      weaponsInputs.forEach((input) => {
        if (input.value.trim()) {
          existingClass.proficiencies.weapons.push(input.value.trim());
        }
      });
      existingClass.proficiencies.armor = [];
      const armorInputs = modalScrollContainer.querySelectorAll('input[name="armor-prof"]');
      armorInputs.forEach((input) => {
        if (input.value.trim()) {
          existingClass.proficiencies.armor.push(input.value.trim());
        }
      });
      existingClass.proficiencies.tools = [];
      const toolInputs = modalScrollContainer.querySelectorAll('input[name="tool-prof"]');
      toolInputs.forEach((input) => {
        if (input.value.trim()) {
          existingClass.proficiencies.tools.push(input.value.trim());
        }
      });
      const isSpellcaster = modalScrollContainer.querySelector("#is-spellcaster");
      if (isSpellcaster && isSpellcaster.checked) {
        const spellAbility = modalScrollContainer.querySelector("#spell-ability");
        const prepareSpells = modalScrollContainer.querySelector("#prepare-spells");
        existingClass.spellcasting = {
          ability: spellAbility.value,
          prepareSpells: prepareSpells.checked
        };
      } else {
        delete existingClass.spellcasting;
      }
      if (index !== void 0) {
        this.plugin.settings.classes[index] = existingClass;
      } else {
        this.plugin.settings.classes.push(existingClass);
      }
      await this.plugin.saveSettings();
      this.display();
      modal.close();
    });
    modal.open();
  }
  /**
   * Render Saving Throws Tab
   */
  renderSavingThrowsTab(container, existingClass) {
    container.createEl("h3", { text: "Saving Throw Proficiencies" });
    container.createEl("p", {
      text: "Select which ability saving throws this class is proficient in (typically two).",
      cls: "setting-item-description"
    });
    const savesContainer = container.createDiv("saves-container");
    savesContainer.style.display = "grid";
    savesContainer.style.gridTemplateColumns = "repeat(3, 1fr)";
    savesContainer.style.gap = "10px";
    savesContainer.style.marginTop = "10px";
    const abilities = ["str", "dex", "con", "int", "wis", "cha"];
    abilities.forEach((ability) => {
      const saveCheck = savesContainer.createDiv("save-check");
      saveCheck.style.display = "flex";
      saveCheck.style.alignItems = "center";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = (existingClass == null ? void 0 : existingClass.savingThrows.includes(ability)) || false;
      checkbox.id = `save-${ability}`;
      saveCheck.appendChild(checkbox);
      const label = document.createElement("label");
      label.textContent = ability.toUpperCase();
      label.htmlFor = `save-${ability}`;
      label.style.marginLeft = "5px";
      saveCheck.appendChild(label);
    });
  }
  /**
   * Render Skills Tab
   */
  renderSkillsTab(container, existingClass) {
    container.createEl("h3", { text: "Class Skills" });
    container.createEl("p", {
      text: "Select which skills this class can choose proficiencies from.",
      cls: "setting-item-description"
    });
    const skillChoiceContainer = container.createDiv("skill-choice-container");
    skillChoiceContainer.style.marginBottom = "15px";
    skillChoiceContainer.createEl("label", {
      text: "Number of skill choices: ",
      attr: { for: "skill-choices" }
    });
    const skillChoiceInput = document.createElement("input");
    skillChoiceInput.type = "number";
    skillChoiceInput.id = "skill-choices";
    skillChoiceInput.min = "1";
    skillChoiceInput.max = "8";
    skillChoiceInput.value = ((existingClass == null ? void 0 : existingClass.skillChoices) || 2).toString();
    skillChoiceInput.style.width = "60px";
    skillChoiceInput.style.marginLeft = "10px";
    skillChoiceContainer.appendChild(skillChoiceInput);
    const skillsContainer = container.createDiv("skills-container");
    skillsContainer.style.display = "grid";
    skillsContainer.style.gridTemplateColumns = "repeat(3, 1fr)";
    skillsContainer.style.gap = "10px";
    const allSkills = [
      "Acrobatics",
      "Animal Handling",
      "Arcana",
      "Athletics",
      "Deception",
      "History",
      "Insight",
      "Intimidation",
      "Investigation",
      "Medicine",
      "Nature",
      "Perception",
      "Performance",
      "Persuasion",
      "Religion",
      "Sleight of Hand",
      "Stealth",
      "Survival"
    ];
    allSkills.forEach((skill) => {
      const skillCheck = skillsContainer.createDiv("skill-check");
      skillCheck.style.display = "flex";
      skillCheck.style.alignItems = "center";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = (existingClass == null ? void 0 : existingClass.skills.includes(skill)) || false;
      checkbox.id = `skill-${skill}`;
      skillCheck.appendChild(checkbox);
      const label = document.createElement("label");
      label.textContent = skill;
      label.htmlFor = `skill-${skill}`;
      label.style.marginLeft = "5px";
      skillCheck.appendChild(label);
    });
  }
  /**
   * Render Features Tab
   */
  renderFeaturesTab(container, existingClass) {
    container.createEl("h3", { text: "Class Features" });
    container.createEl("p", {
      text: "Define the features this class gains as it levels up.",
      cls: "setting-item-description"
    });
    const featuresContainer = container.createDiv("features-container");
    featuresContainer.style.marginTop = "10px";
    const addFeatureRow = (feature) => {
      var _a;
      const featureRow = featuresContainer.createDiv("feature-row");
      featureRow.style.display = "flex";
      featureRow.style.marginBottom = "10px";
      featureRow.style.gap = "10px";
      const levelInput = document.createElement("input");
      levelInput.type = "number";
      levelInput.min = "1";
      levelInput.max = "20";
      levelInput.value = ((_a = feature == null ? void 0 : feature.level) == null ? void 0 : _a.toString()) || "1";
      levelInput.style.width = "60px";
      levelInput.placeholder = "Level";
      featureRow.appendChild(levelInput);
      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.value = (feature == null ? void 0 : feature.name) || "";
      nameInput.style.flex = "1";
      nameInput.placeholder = "Feature name";
      featureRow.appendChild(nameInput);
      const descInput = document.createElement("input");
      descInput.type = "text";
      descInput.value = (feature == null ? void 0 : feature.description) || "";
      descInput.style.flex = "2";
      descInput.placeholder = "Feature description";
      featureRow.appendChild(descInput);
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "\xD7";
      deleteBtn.style.color = "var(--text-error)";
      deleteBtn.addEventListener("click", () => {
        featureRow.remove();
      });
      featureRow.appendChild(deleteBtn);
      return { row: featureRow, levelInput, nameInput, descInput };
    };
    if ((existingClass == null ? void 0 : existingClass.features) && existingClass.features.length > 0) {
      existingClass.features.forEach((feature) => {
        addFeatureRow(feature);
      });
    } else {
      addFeatureRow();
    }
    const addFeatureButton = container.createEl("button", { text: "Add Feature" });
    addFeatureButton.style.marginTop = "10px";
    addFeatureButton.addEventListener("click", () => {
      addFeatureRow();
    });
  }
  /**
   * Render Proficiencies Tab
   */
  renderProficienciesTab(container, existingClass) {
    container.createEl("h3", { text: "Proficiencies" });
    container.createEl("p", {
      text: "Define what equipment this class is proficient with.",
      cls: "setting-item-description"
    });
    const weaponsContainer = container.createDiv("weapons-container");
    weaponsContainer.createEl("h4", { text: "Weapon Proficiencies" });
    const addWeaponProf = (value) => {
      const weaponInput = document.createElement("input");
      weaponInput.type = "text";
      weaponInput.name = "weapon-prof";
      weaponInput.placeholder = "e.g., Simple weapons, Martial weapons";
      weaponInput.value = value || "";
      weaponInput.style.width = "100%";
      weaponInput.style.marginBottom = "5px";
      weaponsContainer.appendChild(weaponInput);
    };
    if ((existingClass == null ? void 0 : existingClass.proficiencies.weapons) && existingClass.proficiencies.weapons.length > 0) {
      existingClass.proficiencies.weapons.forEach((weapon) => {
        addWeaponProf(weapon);
      });
    } else {
      addWeaponProf();
    }
    const addWeaponButton = weaponsContainer.createEl("button", { text: "Add Weapon Proficiency" });
    addWeaponButton.style.fontSize = "0.8em";
    addWeaponButton.style.marginBottom = "15px";
    addWeaponButton.addEventListener("click", () => {
      addWeaponProf();
    });
    const armorContainer = container.createDiv("armor-container");
    armorContainer.createEl("h4", { text: "Armor Proficiencies" });
    const addArmorProf = (value) => {
      const armorInput = document.createElement("input");
      armorInput.type = "text";
      armorInput.name = "armor-prof";
      armorInput.placeholder = "e.g., Light armor, Medium armor, Shields";
      armorInput.value = value || "";
      armorInput.style.width = "100%";
      armorInput.style.marginBottom = "5px";
      armorContainer.appendChild(armorInput);
    };
    if ((existingClass == null ? void 0 : existingClass.proficiencies.armor) && existingClass.proficiencies.armor.length > 0) {
      existingClass.proficiencies.armor.forEach((armor) => {
        addArmorProf(armor);
      });
    } else {
      addArmorProf();
    }
    const addArmorButton = armorContainer.createEl("button", { text: "Add Armor Proficiency" });
    addArmorButton.style.fontSize = "0.8em";
    addArmorButton.style.marginBottom = "15px";
    addArmorButton.addEventListener("click", () => {
      addArmorProf();
    });
    const toolsContainer = container.createDiv("tools-container");
    toolsContainer.createEl("h4", { text: "Tool Proficiencies" });
    const addToolProf = (value) => {
      const toolInput = document.createElement("input");
      toolInput.type = "text";
      toolInput.name = "tool-prof";
      toolInput.placeholder = "e.g., Thieves' tools, Musical instruments";
      toolInput.value = value || "";
      toolInput.style.width = "100%";
      toolInput.style.marginBottom = "5px";
      toolsContainer.appendChild(toolInput);
    };
    if ((existingClass == null ? void 0 : existingClass.proficiencies.tools) && existingClass.proficiencies.tools.length > 0) {
      existingClass.proficiencies.tools.forEach((tool) => {
        addToolProf(tool);
      });
    } else {
      addToolProf();
    }
    const addToolButton = toolsContainer.createEl("button", { text: "Add Tool Proficiency" });
    addToolButton.style.fontSize = "0.8em";
    addToolButton.style.marginBottom = "15px";
    addToolButton.addEventListener("click", () => {
      addToolProf();
    });
  }
  /**
   * Open Custom Parameter Modal for Adding/Editing
   */
  openCustomParameterModal(existingParam) {
    var _a;
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText(existingParam ? `Edit ${existingParam.label} Parameter` : "Add New Custom Parameter");
    const nameContainer = modal.contentEl.createDiv("parameter-name");
    nameContainer.createEl("h3", { text: "Parameter Identification" });
    const nameInput = nameContainer.createEl("input", {
      type: "text",
      placeholder: "Internal parameter name (lowercase, no spaces)",
      value: (existingParam == null ? void 0 : existingParam.name) || ""
    });
    nameInput.style.width = "100%";
    nameContainer.createEl("div", {
      attr: {
        style: "color: var(--text-error); display: none; margin-top: 5px; font-size: 0.9em;",
        id: "name-error"
      }
    });
    const validateName = () => {
      const name = nameInput.value.trim().toLowerCase();
      const nameErrorEl = document.getElementById("name-error");
      if (!nameErrorEl) return false;
      if (!name) {
        nameErrorEl.textContent = "Parameter name is required";
        nameErrorEl.style.display = "block";
        return false;
      }
      const validNameRegex = /^[a-z0-9_]+$/;
      if (!validNameRegex.test(name)) {
        nameErrorEl.textContent = "Name must contain only lowercase letters, numbers, and underscores";
        nameErrorEl.style.display = "block";
        return false;
      }
      const existingNames = this.plugin.settings.customParameters.filter((p) => p !== existingParam).map((p) => p.name);
      if (existingNames.includes(name)) {
        nameErrorEl.textContent = "Parameter name must be unique";
        nameErrorEl.style.display = "block";
        return false;
      }
      nameErrorEl.style.display = "none";
      return true;
    };
    nameInput.addEventListener("blur", validateName);
    const labelContainer = modal.contentEl.createDiv("parameter-label");
    labelContainer.createEl("h3", { text: "Display Settings" });
    const labelInput = labelContainer.createEl("input", {
      type: "text",
      placeholder: "Label to display in UI",
      value: (existingParam == null ? void 0 : existingParam.label) || ""
    });
    labelInput.style.width = "100%";
    const formatContainer = modal.contentEl.createDiv("parameter-format");
    formatContainer.createEl("h3", { text: "Formatting" });
    const formatInput = formatContainer.createEl("input", {
      type: "text",
      placeholder: 'Format template (e.g., "- {content}")',
      value: (existingParam == null ? void 0 : existingParam.format) || '- "{content}"'
    });
    formatInput.style.width = "100%";
    formatContainer.createEl("p", {
      text: "Use {content} for single values or {item} for list items",
      attr: { style: "color: var(--text-muted); font-size: 0.9em; margin-top: 5px;" }
    });
    const previewContainer = modal.contentEl.createDiv("parameter-preview");
    previewContainer.createEl("h3", { text: "Preview" });
    const previewOutput = previewContainer.createEl("div", {
      attr: {
        style: "background: var(--background-secondary); padding: 10px; border-radius: 4px; font-family: var(--font-monospace); margin-top: 5px;"
      }
    });
    const updatePreview = () => {
      const format = formatInput.value || '- "{content}"';
      previewOutput.textContent = format.replace("{content}", "Example content").replace("{item}", "Example item");
    };
    formatInput.addEventListener("input", updatePreview);
    updatePreview();
    const enabledContainer = modal.contentEl.createDiv("parameter-enabled");
    enabledContainer.createEl("h3", { text: "Visibility" });
    const enabledToggle = document.createElement("input");
    enabledToggle.type = "checkbox";
    enabledToggle.checked = (_a = existingParam == null ? void 0 : existingParam.enabled) != null ? _a : true;
    enabledContainer.appendChild(enabledToggle);
    enabledContainer.createEl("label", {
      text: " Enabled (visible in NPC generation)",
      attr: { style: "margin-left: 10px;" }
    });
    const buttonContainer = modal.contentEl.createDiv("button-container");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.gap = "10px";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      modal.close();
    });
    const saveButton = buttonContainer.createEl("button", {
      text: "Save Parameter",
      cls: "mod-cta"
    });
    saveButton.addEventListener("click", async () => {
      if (!validateName()) return;
      const paramToSave = {
        name: nameInput.value.trim().toLowerCase(),
        label: labelInput.value.trim() || "Custom Parameter",
        format: formatInput.value.trim() || '- "{content}"',
        enabled: enabledToggle.checked
      };
      if (existingParam) {
        const paramIndex = this.plugin.settings.customParameters.indexOf(existingParam);
        this.plugin.settings.customParameters[paramIndex] = paramToSave;
      } else {
        this.plugin.settings.customParameters.push(paramToSave);
      }
      await this.plugin.saveSettings();
      this.display();
      modal.close();
    });
    modal.open();
  }
  /**
   * Format race description for display
   */
  formatRaceDescription(race) {
    const bonuses = Object.entries(race.abilityScoreAdjustments).filter(([_, value]) => value !== 0).map(([ability, value]) => `${ability.toUpperCase()} ${value > 0 ? "+" + value : value}`).join(", ");
    return `${bonuses || "No ability adjustments"}`;
  }
  /**
   * Format class description for display
   */
  formatClassDescription(characterClass) {
    return `d${characterClass.hitDie} \u2022 ${characterClass.primaryAbility.toUpperCase()} \u2022 ${characterClass.skills.length} skills`;
  }
};

// src/main.ts
var NPCGenerator = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.settings = {};
  }
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("dice", "Generate NPC", () => {
      new NPCGeneratorModal(this.app, this).open();
    });
    this.addSettingTab(new NPCGeneratorSettingsTab(this.app, this));
    this.addCommand({
      id: "generate-npc",
      name: "Generate NPC",
      callback: () => {
        new NPCGeneratorModal(this.app, this).open();
      }
    });
  }
  async loadSettings() {
    var _a, _b;
    const defaultSettings = {
      races: [
        {
          name: "Human",
          abilityScoreAdjustments: { str: 1, dex: 1, con: 1, int: 1, wis: 1, cha: 1 },
          traits: ["Versatile"],
          size: "Medium",
          speed: 30,
          languages: ["Common"],
          additionalLanguages: 1
        },
        {
          name: "Variant Human",
          abilityScoreAdjustments: { str: 1, dex: 1 },
          // Player can choose any two
          traits: ["Versatile", "Skilled", "Feat"],
          size: "Medium",
          speed: 30,
          languages: ["Common"],
          additionalLanguages: 1
        },
        {
          name: "Elf (High)",
          abilityScoreAdjustments: { dex: 2, int: 1 },
          traits: ["Darkvision", "Fey Ancestry", "Trance", "Keen Senses", "Elf Weapon Training", "Cantrip"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Elvish"],
          additionalLanguages: 1
        },
        {
          name: "Elf (Wood)",
          abilityScoreAdjustments: { dex: 2, wis: 1 },
          traits: ["Darkvision", "Fey Ancestry", "Trance", "Keen Senses", "Elf Weapon Training", "Fleet of Foot", "Mask of the Wild"],
          size: "Medium",
          speed: 35,
          languages: ["Common", "Elvish"]
        },
        {
          name: "Elf (Drow)",
          abilityScoreAdjustments: { dex: 2, cha: 1 },
          traits: ["Superior Darkvision", "Fey Ancestry", "Trance", "Keen Senses", "Drow Magic", "Sunlight Sensitivity", "Drow Weapon Training"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Elvish", "Undercommon"]
        },
        {
          name: "Dwarf (Hill)",
          abilityScoreAdjustments: { con: 2, wis: 1 },
          traits: ["Darkvision", "Dwarven Resilience", "Dwarven Combat Training", "Stonecunning", "Dwarven Toughness"],
          size: "Medium",
          speed: 25,
          languages: ["Common", "Dwarvish"]
        },
        {
          name: "Dwarf (Mountain)",
          abilityScoreAdjustments: { con: 2, str: 2 },
          traits: ["Darkvision", "Dwarven Resilience", "Dwarven Combat Training", "Stonecunning", "Dwarven Armor Training"],
          size: "Medium",
          speed: 25,
          languages: ["Common", "Dwarvish"]
        },
        {
          name: "Halfling (Lightfoot)",
          abilityScoreAdjustments: { dex: 2, cha: 1 },
          traits: ["Lucky", "Brave", "Halfling Nimbleness", "Naturally Stealthy"],
          size: "Small",
          speed: 25,
          languages: ["Common", "Halfling"]
        },
        {
          name: "Halfling (Stout)",
          abilityScoreAdjustments: { dex: 2, con: 1 },
          traits: ["Lucky", "Brave", "Halfling Nimbleness", "Stout Resilience"],
          size: "Small",
          speed: 25,
          languages: ["Common", "Halfling"]
        },
        {
          name: "Dragonborn",
          abilityScoreAdjustments: { str: 2, cha: 1 },
          traits: ["Draconic Ancestry", "Breath Weapon", "Damage Resistance"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Draconic"]
        },
        {
          name: "Gnome (Forest)",
          abilityScoreAdjustments: { int: 2, dex: 1 },
          traits: ["Darkvision", "Gnome Cunning", "Natural Illusionist", "Speak with Small Beasts"],
          size: "Small",
          speed: 25,
          languages: ["Common", "Gnomish"]
        },
        {
          name: "Gnome (Rock)",
          abilityScoreAdjustments: { int: 2, con: 1 },
          traits: ["Darkvision", "Gnome Cunning", "Artificer's Lore", "Tinker"],
          size: "Small",
          speed: 25,
          languages: ["Common", "Gnomish"]
        },
        {
          name: "Half-Elf",
          abilityScoreAdjustments: { cha: 2, dex: 1, wis: 1 },
          // Player can choose any two besides CHA
          traits: ["Darkvision", "Fey Ancestry", "Skill Versatility"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Elvish"],
          additionalLanguages: 1
        },
        {
          name: "Half-Orc",
          abilityScoreAdjustments: { str: 2, con: 1 },
          traits: ["Darkvision", "Menacing", "Relentless Endurance", "Savage Attacks"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Orc"]
        },
        {
          name: "Tiefling",
          abilityScoreAdjustments: { cha: 2, int: 1 },
          traits: ["Darkvision", "Hellish Resistance", "Infernal Legacy"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Infernal"]
        },
        // Races from other sources
        {
          name: "Aasimar (Protector)",
          abilityScoreAdjustments: { cha: 2, wis: 1 },
          traits: ["Darkvision", "Celestial Resistance", "Healing Hands", "Light Bearer", "Radiant Soul"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Celestial"]
        },
        {
          name: "Aasimar (Scourge)",
          abilityScoreAdjustments: { cha: 2, con: 1 },
          traits: ["Darkvision", "Celestial Resistance", "Healing Hands", "Light Bearer", "Radiant Consumption"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Celestial"]
        },
        {
          name: "Aasimar (Fallen)",
          abilityScoreAdjustments: { cha: 2, str: 1 },
          traits: ["Darkvision", "Celestial Resistance", "Healing Hands", "Light Bearer", "Necrotic Shroud"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Celestial"]
        },
        {
          name: "Firbolg",
          abilityScoreAdjustments: { wis: 2, str: 1 },
          traits: ["Firbolg Magic", "Hidden Step", "Powerful Build", "Speech of Beast and Leaf"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Elvish", "Giant"]
        },
        {
          name: "Goliath",
          abilityScoreAdjustments: { str: 2, con: 1 },
          traits: ["Stone's Endurance", "Powerful Build", "Mountain Born", "Natural Athlete"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Giant"]
        },
        {
          name: "Tabaxi",
          abilityScoreAdjustments: { dex: 2, cha: 1 },
          traits: ["Darkvision", "Feline Agility", "Cat's Claws", "Cat's Talent"],
          size: "Medium",
          speed: 30,
          languages: ["Common"],
          additionalLanguages: 1
        },
        {
          name: "Kenku",
          abilityScoreAdjustments: { dex: 2, wis: 1 },
          traits: ["Expert Forgery", "Mimicry", "Kenku Training"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Auran"]
        },
        {
          name: "Triton",
          abilityScoreAdjustments: { str: 1, con: 1, cha: 1 },
          traits: ["Amphibious", "Control Air and Water", "Emissary of the Sea", "Guardians of the Depths"],
          size: "Medium",
          speed: 30,
          languages: ["Common", "Primordial"]
        },
        {
          name: "Leonin",
          abilityScoreAdjustments: { str: 2, con: 1 },
          traits: ["Darkvision", "Claws", "Hunter's Instincts", "Daunting Roar"],
          size: "Medium",
          speed: 35,
          languages: ["Common"]
        },
        {
          name: "Satyr",
          abilityScoreAdjustments: { cha: 2, dex: 1 },
          traits: ["Fey", "Magic Resistance", "Mirthful Leaps", "Reveler"],
          size: "Medium",
          speed: 35,
          languages: ["Common", "Elvish", "Sylvan"]
        },
        {
          name: "Fairy",
          abilityScoreAdjustments: { dex: 2, cha: 1 },
          traits: ["Flight", "Fey", "Fairy Magic"],
          size: "Small",
          speed: 30,
          languages: ["Common", "Sylvan"]
        },
        {
          name: "Harengon",
          abilityScoreAdjustments: { dex: 2, wis: 1 },
          traits: ["Hare-Trigger", "Leporine Senses", "Lucky Footwork", "Rabbit Hop"],
          size: "Medium",
          speed: 30,
          languages: ["Common"],
          additionalLanguages: 1
        }
      ],
      classes: [
        {
          name: "Barbarian",
          hitDie: 12,
          primaryAbility: "str",
          savingThrows: ["str", "con"],
          skills: ["Animal Handling", "Athletics", "Intimidation", "Nature", "Perception", "Survival"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Simple weapons", "Martial weapons"],
            armor: ["Light armor", "Medium armor", "Shields"],
            tools: []
          },
          features: [
            { level: 1, name: "Rage", description: "In battle, you fight with primal ferocity. You can enter a rage as a bonus action." },
            { level: 1, name: "Unarmored Defense", description: "While not wearing armor, your AC equals 10 + your Dexterity modifier + your Constitution modifier." },
            { level: 2, name: "Reckless Attack", description: "You can throw aside all concern for defense to attack with fierce desperation." },
            { level: 2, name: "Danger Sense", description: "You gain an uncanny sense of when things nearby aren't as they should be." }
          ]
        },
        {
          name: "Bard",
          hitDie: 8,
          primaryAbility: "cha",
          savingThrows: ["dex", "cha"],
          skills: ["Acrobatics", "Animal Handling", "Arcana", "Athletics", "Deception", "History", "Insight", "Intimidation", "Investigation", "Medicine", "Nature", "Perception", "Performance", "Persuasion", "Religion", "Sleight of Hand", "Stealth", "Survival"],
          skillChoices: 3,
          proficiencies: {
            weapons: ["Simple weapons", "Hand crossbows", "Longswords", "Rapiers", "Shortswords"],
            armor: ["Light armor"],
            tools: ["Three musical instruments of your choice"]
          },
          spellcasting: {
            ability: "cha",
            cantripsKnown: [2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
            spellsKnown: [4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 15, 16, 18, 19, 19, 20, 22, 22, 22]
          },
          features: [
            { level: 1, name: "Bardic Inspiration", description: "You can inspire others through stirring words or music." },
            { level: 1, name: "Spellcasting", description: "You have learned to untangle and reshape the fabric of reality in harmony with your wishes and music." },
            { level: 2, name: "Jack of All Trades", description: "You can add half your proficiency bonus, rounded down, to any ability check you make that doesn't already include your proficiency bonus." },
            { level: 2, name: "Song of Rest", description: "You can use soothing music or oration to help revitalize your wounded allies during a short rest." }
          ]
        },
        {
          name: "Cleric",
          hitDie: 8,
          primaryAbility: "wis",
          savingThrows: ["wis", "cha"],
          skills: ["History", "Insight", "Medicine", "Persuasion", "Religion"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Simple weapons"],
            armor: ["Light armor", "Medium armor", "Shields"],
            tools: []
          },
          spellcasting: {
            ability: "wis",
            cantripsKnown: [3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            prepareSpells: true
          },
          features: [
            { level: 1, name: "Divine Domain", description: "Choose one domain related to your deity: Knowledge, Life, Light, Nature, Tempest, Trickery, or War." },
            { level: 1, name: "Spellcasting", description: "As a conduit for divine power, you can cast cleric spells." },
            { level: 2, name: "Channel Divinity", description: "You gain the ability to channel divine energy directly from your deity, using that energy to fuel magical effects." },
            { level: 2, name: "Divine Domain Feature", description: "Your divine domain grants you additional abilities." }
          ]
        },
        {
          name: "Druid",
          hitDie: 8,
          primaryAbility: "wis",
          savingThrows: ["int", "wis"],
          skills: ["Arcana", "Animal Handling", "Insight", "Medicine", "Nature", "Perception", "Religion", "Survival"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Clubs", "Daggers", "Darts", "Javelins", "Maces", "Quarterstaffs", "Scimitars", "Sickles", "Slings", "Spears"],
            armor: ["Light armor", "Medium armor", "Shields"],
            tools: ["Herbalism kit"]
          },
          spellcasting: {
            ability: "wis",
            cantripsKnown: [2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
            prepareSpells: true
          },
          features: [
            { level: 1, name: "Druidic", description: "You know Druidic, the secret language of druids." },
            { level: 1, name: "Spellcasting", description: "Drawing on the divine essence of nature itself, you can cast spells to shape that essence to your will." },
            { level: 2, name: "Wild Shape", description: "You can use your action to magically assume the shape of a beast that you have seen before." },
            { level: 2, name: "Druid Circle", description: "You choose to identify with a circle of druids: the Circle of the Land or the Circle of the Moon." }
          ]
        },
        {
          name: "Fighter",
          hitDie: 10,
          primaryAbility: "str",
          savingThrows: ["str", "con"],
          skills: ["Acrobatics", "Animal Handling", "Athletics", "History", "Insight", "Intimidation", "Perception", "Survival"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Simple weapons", "Martial weapons"],
            armor: ["All armor", "Shields"],
            tools: []
          },
          features: [
            { level: 1, name: "Fighting Style", description: "You adopt a particular style of fighting as your specialty." },
            { level: 1, name: "Second Wind", description: "You have a limited well of stamina that you can draw on to protect yourself from harm." },
            { level: 2, name: "Action Surge", description: "You can push yourself beyond your normal limits for a moment." },
            { level: 3, name: "Martial Archetype", description: "You choose an archetype that you strive to emulate in your combat styles and techniques." }
          ]
        },
        {
          name: "Monk",
          hitDie: 8,
          primaryAbility: "dex",
          savingThrows: ["str", "dex"],
          skills: ["Acrobatics", "Athletics", "History", "Insight", "Religion", "Stealth"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Simple weapons", "Shortswords"],
            armor: [],
            tools: ["One type of artisan's tools or one musical instrument"]
          },
          features: [
            { level: 1, name: "Unarmored Defense", description: "While you are wearing no armor and not wielding a shield, your AC equals 10 + your Dexterity modifier + your Wisdom modifier." },
            { level: 1, name: "Martial Arts", description: "Your practice of martial arts gives you mastery of combat styles that use unarmed strikes and monk weapons." },
            { level: 2, name: "Ki", description: "Your training allows you to harness the mystic energy of ki." },
            { level: 2, name: "Unarmored Movement", description: "Your speed increases when you are not wearing armor or wielding a shield." }
          ]
        },
        {
          name: "Paladin",
          hitDie: 10,
          primaryAbility: "str",
          savingThrows: ["wis", "cha"],
          skills: ["Athletics", "Insight", "Intimidation", "Medicine", "Persuasion", "Religion"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Simple weapons", "Martial weapons"],
            armor: ["All armor", "Shields"],
            tools: []
          },
          spellcasting: {
            ability: "cha",
            prepareSpells: true
          },
          features: [
            { level: 1, name: "Divine Sense", description: "The presence of strong evil registers on your senses like a noxious odor." },
            { level: 1, name: "Lay on Hands", description: "Your blessed touch can heal wounds." },
            { level: 2, name: "Fighting Style", description: "You adopt a style of fighting as your specialty." },
            { level: 2, name: "Spellcasting", description: "You have learned to draw on divine magic through meditation and prayer." },
            { level: 2, name: "Divine Smite", description: "When you hit a creature with a melee weapon attack, you can expend one spell slot to deal radiant damage." }
          ]
        },
        {
          name: "Ranger",
          hitDie: 10,
          primaryAbility: "dex",
          savingThrows: ["str", "dex"],
          skills: ["Animal Handling", "Athletics", "Insight", "Investigation", "Nature", "Perception", "Stealth", "Survival"],
          skillChoices: 3,
          proficiencies: {
            weapons: ["Simple weapons", "Martial weapons"],
            armor: ["Light armor", "Medium armor", "Shields"],
            tools: []
          },
          spellcasting: {
            ability: "wis",
            spellsKnown: [0, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11]
          },
          features: [
            { level: 1, name: "Favored Enemy", description: "You have significant experience studying, tracking, hunting, and even talking to a certain type of enemy." },
            { level: 1, name: "Natural Explorer", description: "You are particularly familiar with one type of natural environment and are adept at traveling and surviving in such regions." },
            { level: 2, name: "Fighting Style", description: "You adopt a particular style of fighting as your specialty." },
            { level: 2, name: "Spellcasting", description: "You have learned to use the magical essence of nature to cast spells, much as a druid does." }
          ]
        },
        {
          name: "Rogue",
          hitDie: 8,
          primaryAbility: "dex",
          savingThrows: ["dex", "int"],
          skills: ["Acrobatics", "Athletics", "Deception", "Insight", "Intimidation", "Investigation", "Perception", "Performance", "Persuasion", "Sleight of Hand", "Stealth"],
          skillChoices: 4,
          proficiencies: {
            weapons: ["Simple weapons", "Hand crossbows", "Longswords", "Rapiers", "Shortswords"],
            armor: ["Light armor"],
            tools: ["Thieves' tools"]
          },
          features: [
            { level: 1, name: "Expertise", description: "Choose two of your skill proficiencies, or one of your skill proficiencies and your proficiency with thieves' tools." },
            { level: 1, name: "Sneak Attack", description: "You know how to strike subtly and exploit a foe's distraction." },
            { level: 1, name: "Thieves' Cant", description: "During your rogue training you learned thieves' cant, a secret mix of dialect, jargon, and code." },
            { level: 2, name: "Cunning Action", description: "Your quick thinking and agility allow you to move and act quickly." }
          ]
        },
        {
          name: "Sorcerer",
          hitDie: 6,
          primaryAbility: "cha",
          savingThrows: ["con", "cha"],
          skills: ["Arcana", "Deception", "Insight", "Intimidation", "Persuasion", "Religion"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Daggers", "Darts", "Slings", "Quarterstaffs", "Light crossbows"],
            armor: [],
            tools: []
          },
          spellcasting: {
            ability: "cha",
            cantripsKnown: [4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
            spellsKnown: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15]
          },
          features: [
            { level: 1, name: "Sorcerous Origin", description: "Choose a sorcerous origin, which describes the source of your innate magical power." },
            { level: 1, name: "Spellcasting", description: "An event in your past, or in the life of a parent or ancestor, left an indelible mark on you, infusing you with arcane magic." },
            { level: 2, name: "Font of Magic", description: "You tap into a deep wellspring of magic within yourself." },
            { level: 3, name: "Metamagic", description: "You gain the ability to twist your spells to suit your needs." }
          ]
        },
        {
          name: "Warlock",
          hitDie: 8,
          primaryAbility: "cha",
          savingThrows: ["wis", "cha"],
          skills: ["Arcana", "Deception", "History", "Intimidation", "Investigation", "Nature", "Religion"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Simple weapons"],
            armor: ["Light armor"],
            tools: []
          },
          spellcasting: {
            ability: "cha",
            cantripsKnown: [2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
            spellsKnown: [2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15]
          },
          features: [
            { level: 1, name: "Otherworldly Patron", description: "You have struck a bargain with an otherworldly being of your choice." },
            { level: 1, name: "Pact Magic", description: "Your arcane research and the magic bestowed on you by your patron have given you facility with spells." },
            { level: 2, name: "Eldritch Invocations", description: "In your study of occult lore, you have unearthed eldritch invocations, fragments of forbidden knowledge that imbue you with an abiding magical ability." },
            { level: 3, name: "Pact Boon", description: "Your otherworldly patron bestows a gift upon you for your loyal service." }
          ]
        },
        {
          name: "Wizard",
          hitDie: 6,
          primaryAbility: "int",
          savingThrows: ["int", "wis"],
          skills: ["Arcana", "History", "Insight", "Investigation", "Medicine", "Religion"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Daggers", "Darts", "Slings", "Quarterstaffs", "Light crossbows"],
            armor: [],
            tools: []
          },
          spellcasting: {
            ability: "int",
            cantripsKnown: [3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            prepareSpells: true
          },
          features: [
            { level: 1, name: "Arcane Recovery", description: "You have learned to regain some of your magical energy by studying your spellbook." },
            { level: 1, name: "Spellcasting", description: "As a student of arcane magic, you have a spellbook containing spells that show the first glimmerings of your true power." },
            { level: 2, name: "Arcane Tradition", description: "You choose an arcane tradition, shaping your practice of magic through one of eight schools." },
            { level: 3, name: "Arcane Tradition Feature", description: "Your arcane tradition grants you additional abilities." }
          ]
        },
        // Classes from other sources
        {
          name: "Artificer",
          hitDie: 8,
          primaryAbility: "int",
          savingThrows: ["con", "int"],
          skills: ["Arcana", "History", "Investigation", "Medicine", "Nature", "Perception", "Sleight of Hand"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Simple weapons", "Firearms"],
            armor: ["Light armor", "Medium armor", "Shields"],
            tools: ["Thieves' tools", "Tinker's tools", "One type of artisan's tools of your choice"]
          },
          spellcasting: {
            ability: "int",
            prepareSpells: true
          },
          features: [
            { level: 1, name: "Magical Tinkering", description: "You have learned how to invest a spark of magic into mundane objects." },
            { level: 1, name: "Spellcasting", description: "You have studied the workings of magic and how to cast spells, channeling the magic through objects." },
            { level: 2, name: "Infuse Item", description: "You gain the ability to imbue mundane items with certain magical infusions." },
            { level: 3, name: "Artificer Specialist", description: "You choose the type of specialist you are: Alchemist, Artillerist, Battle Smith, or Armorer." }
          ]
        },
        {
          name: "Blood Hunter",
          hitDie: 10,
          primaryAbility: "str",
          savingThrows: ["dex", "int"],
          skills: ["Acrobatics", "Arcana", "Athletics", "History", "Insight", "Investigation", "Religion", "Survival"],
          skillChoices: 3,
          proficiencies: {
            weapons: ["Simple weapons", "Martial weapons"],
            armor: ["Light armor", "Medium armor", "Shields"],
            tools: ["Alchemist's supplies"]
          },
          features: [
            { level: 1, name: "Hunter's Bane", description: "You can track certain types of creatures with unnatural efficiency." },
            { level: 1, name: "Blood Maledict", description: "You gain the ability to channel your vital essence into curses against your foes." },
            { level: 2, name: "Crimson Rite", description: "You can imbue your weapon strikes with elemental energy." },
            { level: 3, name: "Blood Hunter Order", description: "You commit to an order of blood hunter martial traditions." }
          ]
        },
        {
          name: "Echo Knight",
          hitDie: 10,
          primaryAbility: "str",
          savingThrows: ["str", "con"],
          skills: ["Acrobatics", "Animal Handling", "Athletics", "History", "Insight", "Intimidation", "Perception", "Survival"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Simple weapons", "Martial weapons"],
            armor: ["All armor", "Shields"],
            tools: []
          },
          features: [
            { level: 1, name: "Fighting Style", description: "You adopt a style of fighting as your specialty." },
            { level: 1, name: "Second Wind", description: "You can use a bonus action to regain hit points." },
            { level: 3, name: "Manifest Echo", description: "You can use a bonus action to magically manifest an echo of yourself." },
            { level: 3, name: "Unleash Incarnation", description: "You can heighten your echo's fury." }
          ]
        },
        {
          name: "Chronurgy Wizard",
          hitDie: 6,
          primaryAbility: "int",
          savingThrows: ["int", "wis"],
          skills: ["Arcana", "History", "Insight", "Investigation", "Medicine", "Religion"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Daggers", "Darts", "Slings", "Quarterstaffs", "Light crossbows"],
            armor: [],
            tools: []
          },
          spellcasting: {
            ability: "int",
            cantripsKnown: [3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            prepareSpells: true
          },
          features: [
            { level: 1, name: "Arcane Recovery", description: "You have learned to regain some of your magical energy by studying your spellbook." },
            { level: 1, name: "Spellcasting", description: "You have a spellbook containing spells that show the first glimmerings of your true power." },
            { level: 2, name: "Chronurgy Magic", description: "You focus your studies on time manipulation, rewinding the flow of time to safeguard yourself and your allies." },
            { level: 2, name: "Temporal Awareness", description: "You can add your Intelligence modifier to your initiative rolls." }
          ]
        },
        {
          name: "Graviturgy Wizard",
          hitDie: 6,
          primaryAbility: "int",
          savingThrows: ["int", "wis"],
          skills: ["Arcana", "History", "Insight", "Investigation", "Medicine", "Religion"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Daggers", "Darts", "Slings", "Quarterstaffs", "Light crossbows"],
            armor: [],
            tools: []
          },
          spellcasting: {
            ability: "int",
            cantripsKnown: [3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            prepareSpells: true
          },
          features: [
            { level: 1, name: "Arcane Recovery", description: "You have learned to regain some of your magical energy by studying your spellbook." },
            { level: 1, name: "Spellcasting", description: "You have a spellbook containing spells that show the first glimmerings of your true power." },
            { level: 2, name: "Graviturgy Magic", description: "Your fascination with gravity has led you to learn spells that manipulate it." },
            { level: 2, name: "Adjust Density", description: "As an action, you can magically alter the weight of a creature or object." }
          ]
        },
        {
          name: "College of Eloquence Bard",
          hitDie: 8,
          primaryAbility: "cha",
          savingThrows: ["dex", "cha"],
          skills: ["Acrobatics", "Animal Handling", "Arcana", "Athletics", "Deception", "History", "Insight", "Intimidation", "Investigation", "Medicine", "Nature", "Perception", "Performance", "Persuasion", "Religion", "Sleight of Hand", "Stealth", "Survival"],
          skillChoices: 3,
          proficiencies: {
            weapons: ["Simple weapons", "Hand crossbows", "Longswords", "Rapiers", "Shortswords"],
            armor: ["Light armor"],
            tools: ["Three musical instruments of your choice"]
          },
          spellcasting: {
            ability: "cha",
            cantripsKnown: [2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
            spellsKnown: [4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 15, 16, 18, 19, 19, 20, 22, 22, 22]
          },
          features: [
            { level: 1, name: "Bardic Inspiration", description: "You can inspire others through stirring words or music." },
            { level: 1, name: "Spellcasting", description: "You have learned to untangle and reshape the fabric of reality." },
            { level: 3, name: "Silver Tongue", description: "You are a master at saying the right thing at the right time." },
            { level: 3, name: "Unsettling Words", description: "You can use your bardic inspiration to undermine someone else's confidence." }
          ]
        },
        {
          name: "Circle of Stars Druid",
          hitDie: 8,
          primaryAbility: "wis",
          savingThrows: ["int", "wis"],
          skills: ["Arcana", "Animal Handling", "Insight", "Medicine", "Nature", "Perception", "Religion", "Survival"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Clubs", "Daggers", "Darts", "Javelins", "Maces", "Quarterstaffs", "Scimitars", "Sickles", "Slings", "Spears"],
            armor: ["Light armor", "Medium armor", "Shields"],
            tools: ["Herbalism kit"]
          },
          spellcasting: {
            ability: "wis",
            cantripsKnown: [2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
            prepareSpells: true
          },
          features: [
            { level: 1, name: "Druidic", description: "You know Druidic, the secret language of druids." },
            { level: 1, name: "Spellcasting", description: "Drawing on the divine essence of nature itself, you can cast spells." },
            { level: 2, name: "Wild Shape", description: "You can use your action to magically assume the shape of a beast." },
            { level: 2, name: "Star Map", description: "You've created a star map, a mystical chart to track heavenly bodies." },
            { level: 2, name: "Starry Form", description: "You can expend a use of your Wild Shape to take on a starry form." }
          ]
        },
        {
          name: "Path of Wild Magic Barbarian",
          hitDie: 12,
          primaryAbility: "str",
          savingThrows: ["str", "con"],
          skills: ["Animal Handling", "Athletics", "Intimidation", "Nature", "Perception", "Survival"],
          skillChoices: 2,
          proficiencies: {
            weapons: ["Simple weapons", "Martial weapons"],
            armor: ["Light armor", "Medium armor", "Shields"],
            tools: []
          },
          features: [
            { level: 1, name: "Rage", description: "In battle, you fight with primal ferocity." },
            { level: 1, name: "Unarmored Defense", description: "While not wearing armor, your AC equals 10 + your Dexterity modifier + your Constitution modifier." },
            { level: 3, name: "Magic Awareness", description: "As an action, you can open your awareness to the presence of magic." },
            { level: 3, name: "Wild Surge", description: "When you enter your rage, roll on the Wild Magic table to determine the magical effect that manifests." }
          ]
        }
      ],
      customParameters: [],
      statblockFormat: "fantasyStatblock"
    };
    const fighterClass = defaultSettings.classes.find((c) => c.name === "Fighter");
    if (fighterClass) {
      fighterClass.subclasses = [
        {
          name: "Champion",
          description: "A simple but powerful archetype that focuses on weapon combat through improved critical hits and superior physical attributes.",
          features: [
            { level: 3, name: "Improved Critical", description: "Your weapon attacks score a critical hit on a roll of 19 or 20." },
            { level: 7, name: "Remarkable Athlete", description: "You can add half your proficiency bonus to any Strength, Dexterity, or Constitution check you make that doesn't already use your proficiency bonus." }
          ]
        },
        {
          name: "Battle Master",
          description: "A skilled warrior who uses combat maneuvers and tactical acumen to control the battlefield.",
          features: [
            { level: 3, name: "Combat Superiority", description: "You learn maneuvers that are fueled by special dice called superiority dice." },
            { level: 3, name: "Student of War", description: "You gain proficiency with one type of artisan's tools of your choice." }
          ]
        },
        {
          name: "Eldritch Knight",
          description: "An arcane warrior who combines martial prowess with magical ability, focusing on abjuration and evocation spells.",
          features: [
            { level: 3, name: "Spellcasting", description: "You learn to cast wizard spells alongside your martial abilities." },
            { level: 3, name: "Weapon Bond", description: "You learn a ritual that creates a magical bond between yourself and one weapon." }
          ]
        }
      ];
    }
    const wizardClass = defaultSettings.classes.find((c) => c.name === "Wizard");
    if (wizardClass) {
      wizardClass.subclasses = [
        {
          name: "School of Evocation",
          description: "Focuses on channeling powerful elemental energies to destroy opponents.",
          features: [
            { level: 2, name: "Evocation Savant", description: "The gold and time you must spend to copy an evocation spell into your spellbook is halved." },
            { level: 2, name: "Sculpt Spells", description: "You can create pockets of relative safety within the effects of your evocation spells." }
          ]
        },
        {
          name: "School of Abjuration",
          description: "Specializes in protective magic and warding against attacks and other spells.",
          features: [
            { level: 2, name: "Abjuration Savant", description: "The gold and time you must spend to copy an abjuration spell into your spellbook is halved." },
            { level: 2, name: "Arcane Ward", description: "You can weave abjuration magic around yourself for protection." }
          ]
        },
        {
          name: "School of Divination",
          description: "Masters the ability to see into the past, present, and future.",
          features: [
            { level: 2, name: "Divination Savant", description: "The gold and time you must spend to copy a divination spell into your spellbook is halved." },
            { level: 2, name: "Portent", description: "Glimpses of the future allow you to replace attack rolls, saving throws, or ability checks." }
          ]
        }
      ];
    }
    const rogueClass = defaultSettings.classes.find((c) => c.name === "Rogue");
    if (rogueClass) {
      rogueClass.subclasses = [
        {
          name: "Thief",
          description: "A rogue who excels at stealth, burglary, and using items with great skill.",
          features: [
            { level: 3, name: "Fast Hands", description: "You can use the bonus action granted by your Cunning Action to make a Dexterity (Sleight of Hand) check, use your thieves' tools, or use an object." },
            { level: 3, name: "Second-Story Work", description: "You gain the ability to climb faster than normal and jump farther." }
          ]
        },
        {
          name: "Assassin",
          description: "A rogue who specializes in disguise and eliminating targets quickly and efficiently.",
          features: [
            { level: 3, name: "Bonus Proficiencies", description: "You gain proficiency with the disguise kit and the poisoner's kit." },
            { level: 3, name: "Assassinate", description: "You are at your deadliest when you get the drop on your enemies." }
          ]
        },
        {
          name: "Arcane Trickster",
          description: "A rogue who enhances their skills with magic, focusing on illusion and enchantment.",
          features: [
            { level: 3, name: "Spellcasting", description: "You augment your roguish skills with the ability to cast spells." },
            { level: 3, name: "Mage Hand Legerdemain", description: "You can make your mage hand invisible, and you can perform additional tasks with it." }
          ]
        }
      ];
    }
    const savedData = await this.loadData();
    this.settings = {
      races: ((_a = savedData == null ? void 0 : savedData.races) == null ? void 0 : _a.length) > 5 ? savedData.races : defaultSettings.races,
      classes: ((_b = savedData == null ? void 0 : savedData.classes) == null ? void 0 : _b.length) > 5 ? savedData.classes : defaultSettings.classes,
      customParameters: (savedData == null ? void 0 : savedData.customParameters) || [],
      statblockFormat: (savedData == null ? void 0 : savedData.statblockFormat) || "fantasyStatblock"
    };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Generate an NPC based on provided options
   * @param options Generation options
   * @returns Generated NPC
   */
  generateNPC(options = {}) {
    var _a;
    const defaults = {
      level: Math.floor(Math.random() * 20) + 1,
      race: this.getRandomRace().name,
      class: this.getRandomClass().name,
      alignment: NPCGenerationUtils.generateAlignment()
    };
    const mergedOptions = { ...defaults, ...options };
    const race = this.settings.races.find((r) => r.name === mergedOptions.race);
    const characterClass = this.settings.classes.find((c) => c.name === mergedOptions.class);
    let subclass = null;
    if (characterClass.subclasses && characterClass.subclasses.length > 0) {
      if (mergedOptions.subclass) {
        console.log(`Looking for subclass: ${mergedOptions.subclass}`);
        subclass = characterClass.subclasses.find((s) => s.name === mergedOptions.subclass);
        if (subclass) {
          console.log(`Found subclass: ${subclass.name}`);
        } else {
          console.log(`Subclass not found: ${mergedOptions.subclass}`);
        }
      } else if (mergedOptions.subclass !== "None") {
        const subclassLevel = characterClass.name === "Wizard" ? 2 : 3;
        if (mergedOptions.level >= subclassLevel) {
          subclass = characterClass.subclasses[Math.floor(Math.random() * characterClass.subclasses.length)];
          console.log(`Randomly selected subclass: ${subclass.name}`);
        }
      }
    }
    let abilityScores = NPCGenerationUtils.generateAbilityScores();
    abilityScores = NPCGenerationUtils.applyRacialAdjustments(abilityScores, race);
    const abilityModifiers = NPCGenerationUtils.calculateAbilityModifiers(abilityScores);
    const hitPoints = NPCGenerationUtils.calculateHitPoints(
      characterClass,
      (_a = abilityModifiers.con) != null ? _a : 0,
      mergedOptions.level
    );
    const skills = NPCGenerationUtils.generateSkills(
      characterClass,
      abilityModifiers,
      mergedOptions.level
    );
    const proficiencyBonus = NPCGenerationUtils.calculateProficiencyBonus(mergedOptions.level);
    const name = NPCGenerationUtils.generateName(race);
    const possessions = PossessionsUtils.generatePossessions(characterClass);
    const spellcasting = SpellcastingUtils.isSpellcaster(characterClass) ? SpellcastingUtils.generateSpellcasting(
      characterClass,
      abilityModifiers,
      mergedOptions.level
    ) : void 0;
    const customParameters = {};
    if (spellcasting) {
      customParameters.spellcasting = spellcasting;
    }
    return {
      name,
      level: mergedOptions.level,
      race: race.name,
      class: characterClass.name,
      subclass: subclass ? subclass.name : void 0,
      alignment: mergedOptions.alignment,
      abilityScores,
      abilityModifiers,
      hitPoints,
      proficiencyBonus,
      skills,
      traits: race.traits,
      possessions,
      customParameters
    };
  }
  /**
   * Get a random race from settings
   * @returns Race
   */
  getRandomRace() {
    return this.settings.races[Math.floor(Math.random() * this.settings.races.length)];
  }
  /**
   * Get a random class from settings
   * @returns CharacterClass
   */
  getRandomClass() {
    return this.settings.classes[Math.floor(Math.random() * this.settings.classes.length)];
  }
  /**
   * Format NPC statblock
   * @param npc NPC to format
   * @returns Formatted statblock string
   */
  formatStatblock(npc) {
    if (this.settings.statblockFormat === "fantasyStatblock") {
      return this.formatFantasyStatblock(npc);
    } else {
      return this.formatBasicStatblock(npc);
    }
  }
  /**
   * Format NPC using Fantasy Statblock format
   * @param npc NPC to format
   * @returns Formatted Fantasy Statblock string
   */
  formatFantasyStatblock(npc) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
    const characterClass = this.settings.classes.find((c) => c.name === npc.class);
    if (!characterClass) {
      throw new Error(`Class ${npc.class} not found`);
    }
    const race = this.settings.races.find((r) => r.name === npc.race);
    if (!race) {
      throw new Error(`Race ${npc.race} not found`);
    }
    const hitDie = characterClass.hitDie || 8;
    const strAttackBonus = ((_a = npc.abilityModifiers.str) != null ? _a : 0) + npc.proficiencyBonus;
    const dexAttackBonus = ((_b = npc.abilityModifiers.dex) != null ? _b : 0) + npc.proficiencyBonus;
    const isPrimaryStrength = characterClass.primaryAbility === "str" || ((_c = npc.abilityModifiers.str) != null ? _c : 0) > ((_d = npc.abilityModifiers.dex) != null ? _d : 0);
    const primaryAttackBonus = isPrimaryStrength ? strAttackBonus : dexAttackBonus;
    const primaryDamageBonus = isPrimaryStrength ? (_e = npc.abilityModifiers.str) != null ? _e : 0 : (_f = npc.abilityModifiers.dex) != null ? _f : 0;
    const attackType = isPrimaryStrength ? "Longsword" : "Shortsword";
    const attackDamage = isPrimaryStrength ? "1d8" : "1d6";
    const damageType = "slashing";
    const damageDie = parseInt(attackDamage.split("d")[1]);
    const averageDamage = Math.ceil(damageDie / 2) + 1 + primaryDamageBonus;
    const languageList = ((_g = race.languages) == null ? void 0 : _g.join(", ")) || "Common";
    const subclassContent = npc.subclass ? this.getSubclassFeatures(characterClass, npc.subclass, npc.level) : "";
    return `\`\`\`statblock
name: ${npc.name}
source: NPC Generator
size: ${(race == null ? void 0 : race.size) || "Medium"}
type: humanoid
subtype: ${npc.race.toLowerCase()}
alignment: ${npc.alignment.toLowerCase()}
ac: ${10 + ((_h = npc.abilityModifiers.dex) != null ? _h : 0)}
hp: ${npc.hitPoints}
hit_dice: ${npc.level}d${hitDie} + ${npc.level * ((_i = npc.abilityModifiers.con) != null ? _i : 0)}
speed: ${(race == null ? void 0 : race.speed) || 30} ft.
stats:
  - ${npc.abilityScores.str}
  - ${npc.abilityScores.dex}
  - ${npc.abilityScores.con}
  - ${npc.abilityScores.int}
  - ${npc.abilityScores.wis}
  - ${npc.abilityScores.cha}
saves:
  - strength: ${((_j = npc.abilityModifiers.str) != null ? _j : 0) + ((characterClass == null ? void 0 : characterClass.savingThrows.includes("str")) ? npc.proficiencyBonus : 0)}
  - dexterity: ${((_k = npc.abilityModifiers.dex) != null ? _k : 0) + ((characterClass == null ? void 0 : characterClass.savingThrows.includes("dex")) ? npc.proficiencyBonus : 0)}
  - constitution: ${((_l = npc.abilityModifiers.con) != null ? _l : 0) + ((characterClass == null ? void 0 : characterClass.savingThrows.includes("con")) ? npc.proficiencyBonus : 0)}
  - intelligence: ${((_m = npc.abilityModifiers.int) != null ? _m : 0) + ((characterClass == null ? void 0 : characterClass.savingThrows.includes("int")) ? npc.proficiencyBonus : 0)}
  - wisdom: ${((_n = npc.abilityModifiers.wis) != null ? _n : 0) + ((characterClass == null ? void 0 : characterClass.savingThrows.includes("wis")) ? npc.proficiencyBonus : 0)}
  - charisma: ${((_o = npc.abilityModifiers.cha) != null ? _o : 0) + ((characterClass == null ? void 0 : characterClass.savingThrows.includes("cha")) ? npc.proficiencyBonus : 0)}
skillsaves:
${Object.entries(npc.skills).filter(([_, value]) => value !== 0).map(([skill, bonus]) => `  - ${skill.toLowerCase()}: ${bonus}`).join("\n")}
damage_vulnerabilities: ""
damage_resistances: ""
damage_immunities: ""
condition_immunities: ""
senses: ${(race == null ? void 0 : race.traits.includes("Darkvision")) ? "darkvision 60 ft., " : ""}passive Perception ${10 + ((_p = npc.skills["Perception"]) != null ? _p : 0)}
languages: ${languageList}
cr: "${Math.max(1, Math.floor(npc.level / 4))}"
bestiary: true
traits:
${npc.traits.map((trait) => `  - name: ${trait}
    desc: ${this.getTraitDescription(trait, npc.race)}
    attack_bonus: 0`).join("\n")}
${((_q = characterClass == null ? void 0 : characterClass.features) == null ? void 0 : _q.filter((f) => f.level <= npc.level).map((feature) => `  - name: ${feature.name}
    desc: ${feature.description}
    attack_bonus: 0`).join("\n")) || ""}
${subclassContent}
actions:
  - name: ${attackType}
    desc: "Melee Weapon Attack: +${primaryAttackBonus} to hit, reach 5 ft., one target. Hit: ${averageDamage} (${attackDamage} + ${primaryDamageBonus}) ${damageType} damage."
    attack_bonus: ${primaryAttackBonus}
    damage_dice: ${attackDamage}
    damage_bonus: ${primaryDamageBonus}
${npc.customParameters.spellcasting ? `spells:
  - "The ${npc.name} is a level ${npc.level} spellcaster. Its spellcasting ability is ${npc.customParameters.spellcasting.ability} (spell save DC ${npc.customParameters.spellcasting.saveDC}, +${npc.customParameters.spellcasting.attackBonus} to hit with spell attacks)."
  - Cantrips (at will): ${SpellcastingUtils.getCantrips(npc.class).slice(0, npc.customParameters.spellcasting.cantripsKnown).join(", ")}
${Object.entries(npc.customParameters.spellcasting.slots).filter(([_, slots]) => Number(slots) > 0).map(
      ([level, slots]) => `  - ${this.getOrdinal(parseInt(level))} level (${slots} slots): ${SpellcastingUtils.getSpellsByClassAndLevel(npc.class, parseInt(level)).slice(0, Math.min(4, Number(slots) + 1)).join(", ")}`
    ).join("\n")}` : ""}
possessions:
${this.formatPossessions(npc.possessions)}
\`\`\``;
  }
  // Get subclass features for statblock
  getSubclassFeatures(characterClass, subclassName, level) {
    var _a;
    console.log(`Getting features for subclass: ${subclassName}`);
    const subclass = (_a = characterClass.subclasses) == null ? void 0 : _a.find((s) => s.name === subclassName);
    if (!subclass) {
      console.log(`Subclass not found: ${subclassName}`);
      return "";
    }
    console.log(`Found subclass: ${subclass.name} with ${subclass.features.length} features`);
    return subclass.features.filter((feature) => feature.level <= level).map((feature) => {
      const sanitizeName = feature.name.replace(/['"]/g, "");
      const sanitizeDesc = feature.description.replace(/['"]/g, "").replace(/`/g, "").replace(/\n/g, " ");
      console.log(`Adding feature: ${sanitizeName}`);
      return `  - name: ${sanitizeName} (${subclassName})
    desc: ${sanitizeDesc}
    attack_bonus: 0`;
    }).join("\n");
  }
  /**
   * Format possessions for statblock
   */
  formatPossessions(possessions) {
    return possessions.map((item) => {
      if (typeof item === "string") {
        return ` - name: ${item}`;
      } else if (typeof item === "object" && item !== null) {
        if ("desc" in item && "name" in item) {
          return ` - name: ${item.name}
   desc: ${item.desc}`;
        } else if ("name" in item) {
          return ` - name: ${item.name}`;
        }
      }
      return ` - name: ${String(item)}`;
    }).join("\n");
  }
  /**
   * Format NPC using Basic Text format
   * @param npc NPC to format
   * @returns Formatted Basic Text string
   */
  formatBasicStatblock(npc) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
    const characterClass = this.settings.classes.find((c) => c.name === npc.class);
    if (!characterClass) {
      throw new Error(`Class ${npc.class} not found`);
    }
    const race = this.settings.races.find((r) => r.name === npc.race);
    if (!race) {
      throw new Error(`Race ${npc.race} not found`);
    }
    const hitDie = characterClass.hitDie || 8;
    const strAttackBonus = ((_a = npc.abilityModifiers.str) != null ? _a : 0) + npc.proficiencyBonus;
    const dexAttackBonus = ((_b = npc.abilityModifiers.dex) != null ? _b : 0) + npc.proficiencyBonus;
    const isPrimaryStrength = characterClass.primaryAbility === "str" || ((_c = npc.abilityModifiers.str) != null ? _c : 0) > ((_d = npc.abilityModifiers.dex) != null ? _d : 0);
    const primaryAttackBonus = isPrimaryStrength ? strAttackBonus : dexAttackBonus;
    const primaryDamageBonus = isPrimaryStrength ? (_e = npc.abilityModifiers.str) != null ? _e : 0 : (_f = npc.abilityModifiers.dex) != null ? _f : 0;
    const attackType = isPrimaryStrength ? "Longsword" : "Shortsword";
    const attackDamage = isPrimaryStrength ? "1d8" : "1d6";
    const damageType = "slashing";
    const damageDie = parseInt(attackDamage.split("d")[1]);
    const averageDamage = Math.ceil(damageDie / 2) + 1 + primaryDamageBonus;
    const languageList = ((_g = race.languages) == null ? void 0 : _g.join(", ")) || "Common";
    return `name: ${npc.name}
source: NPC Generator
size: ${(race == null ? void 0 : race.size) || "Medium"}
type: humanoid
subtype: ${npc.race.toLowerCase()}
alignment: ${npc.alignment.toLowerCase()}
ac: ${10 + ((_h = npc.abilityModifiers.dex) != null ? _h : 0)}
hp: ${npc.hitPoints}
hit_dice: ${npc.level}d${hitDie} + ${npc.level * ((_i = npc.abilityModifiers.con) != null ? _i : 0)}
speed: ${(race == null ? void 0 : race.speed) || 30} ft.
stats:
  - ${npc.abilityScores.str}
  - ${npc.abilityScores.dex}
  - ${npc.abilityScores.con}
  - ${npc.abilityScores.int}
  - ${npc.abilityScores.wis}
  - ${npc.abilityScores.cha}
saves:
  - strength: ${((_j = npc.abilityModifiers.str) != null ? _j : 0) + ((characterClass == null ? void 0 : characterClass.savingThrows.includes("str")) ? npc.proficiencyBonus : 0)}
  - dexterity: ${((_k = npc.abilityModifiers.dex) != null ? _k : 0) + ((characterClass == null ? void 0 : characterClass.savingThrows.includes("dex")) ? npc.proficiencyBonus : 0)}
  - constitution: ${((_l = npc.abilityModifiers.con) != null ? _l : 0) + ((characterClass == null ? void 0 : characterClass.savingThrows.includes("con")) ? npc.proficiencyBonus : 0)}
  - intelligence: ${((_m = npc.abilityModifiers.int) != null ? _m : 0) + ((characterClass == null ? void 0 : characterClass.savingThrows.includes("int")) ? npc.proficiencyBonus : 0)}
  - wisdom: ${((_n = npc.abilityModifiers.wis) != null ? _n : 0) + ((characterClass == null ? void 0 : characterClass.savingThrows.includes("wis")) ? npc.proficiencyBonus : 0)}
  - charisma: ${((_o = npc.abilityModifiers.cha) != null ? _o : 0) + ((characterClass == null ? void 0 : characterClass.savingThrows.includes("cha")) ? npc.proficiencyBonus : 0)}
skillsaves:
${Object.entries(npc.skills).filter(([_, value]) => value !== 0).map(([skill, bonus]) => `  - ${skill.toLowerCase()}: ${bonus}`).join("\n")}
damage_vulnerabilities: ""
damage_resistances: ""
damage_immunities: ""
condition_immunities: ""
senses: ${(race == null ? void 0 : race.traits.includes("Darkvision")) ? "darkvision 60 ft., " : ""}passive Perception ${10 + ((_p = npc.skills["Perception"]) != null ? _p : 0)}
languages: ${languageList}
cr: "${Math.max(1, Math.floor(npc.level / 4))}"
bestiary: true
traits:
${npc.traits.map((trait) => `  - name: ${trait}
    desc: ${this.getTraitDescription(trait, npc.race)}
    attack_bonus: 0`).join("\n")}
${((_q = characterClass == null ? void 0 : characterClass.features) == null ? void 0 : _q.filter((f) => f.level <= npc.level).map((feature) => `  - name: ${feature.name}
    desc: ${feature.description}
    attack_bonus: 0`).join("\n")) || ""}
${npc.subclass ? this.getSubclassFeatures(characterClass, npc.subclass, npc.level) : ""}
actions:
  - name: ${attackType}
    desc: "Melee Weapon Attack: +${primaryAttackBonus} to hit, reach 5 ft., one target. Hit: ${averageDamage} (${attackDamage} + ${primaryDamageBonus}) ${damageType} damage."
    attack_bonus: ${primaryAttackBonus}
    damage_dice: ${attackDamage}
    damage_bonus: ${primaryDamageBonus}
${npc.customParameters.spellcasting ? `spells:
  - "The ${npc.name} is a level ${npc.level} spellcaster. Its spellcasting ability is ${npc.customParameters.spellcasting.ability} (spell save DC ${npc.customParameters.spellcasting.saveDC}, +${npc.customParameters.spellcasting.attackBonus} to hit with spell attacks)."
  - Cantrips (at will): ${SpellcastingUtils.getCantrips(npc.class).slice(0, npc.customParameters.spellcasting.cantripsKnown).join(", ")}
${Object.entries(npc.customParameters.spellcasting.slots).filter(([_, slots]) => Number(slots) > 0).map(
      ([level, slots]) => `  - ${this.getOrdinal(parseInt(level))} level (${slots} slots): ${SpellcastingUtils.getSpellsByClassAndLevel(npc.class, parseInt(level)).slice(0, Math.min(4, Number(slots) + 1)).join(", ")}`
    ).join("\n")}` : ""}
possessions:
${this.formatPossessions(npc.possessions)}`;
  }
  /**
   * Get ordinal suffix for a number
   * @param n Number to format
   * @returns Number with ordinal suffix
   */
  getOrdinal(n) {
    const suffixes = ["th", "st", "nd", "rd"];
    const remainder = n % 100;
    return n + (suffixes[(remainder - 20) % 10] || suffixes[remainder] || suffixes[0]);
  }
  /**
  * Get description for racial traits
  */
  getTraitDescription(trait, race) {
    const traitDescriptions = {
      // Basic traits
      "Darkvision": "Can see in dim light within 60 feet as if it were bright light, and in darkness as if it were dim light.",
      "Superior Darkvision": "Can see in dim light within 120 feet as if it were bright light, and in darkness as if it were dim light.",
      "Fey Ancestry": "Has advantage on saving throws against being charmed, and magic can't put it to sleep.",
      "Trance": "Doesn't need to sleep, but meditates semiconsciously for 4 hours a day.",
      "Keen Senses": "Has proficiency in the Perception skill.",
      "Dwarven Resilience": "Has advantage on saving throws against poison, and has resistance against poison damage.",
      "Stonecunning": "Has doubled proficiency bonus when making Intelligence (History) checks related to stonework.",
      "Dwarven Combat Training": "Has proficiency with the battleaxe, handaxe, light hammer, and warhammer.",
      "Lucky": "When rolling a 1 on an attack roll, ability check, or saving throw, can reroll the die and must use the new roll.",
      "Brave": "Has advantage on saving throws against being frightened.",
      "Halfling Nimbleness": "Can move through the space of any creature that is of a size larger than yours.",
      "Versatile": "Gains proficiency in one additional skill of your choice.",
      "Skilled": "Gains proficiency in one skill of your choice, one tool of your choice, and one language of your choice.",
      "Feat": "Gains one Feat of your choice.",
      // Elf traits
      "Elf Weapon Training": "Has proficiency with the longsword, shortsword, shortbow, and longbow.",
      "Cantrip": "Knows one cantrip of your choice from the wizard spell list.",
      "Fleet of Foot": "Base walking speed increases to 35 feet.",
      "Mask of the Wild": "Can attempt to hide even when only lightly obscured by foliage, heavy rain, falling snow, mist, and other natural phenomena.",
      "Drow Magic": "Knows the dancing lights cantrip. At 3rd level, can cast faerie fire once per day. At 5th level, can cast darkness once per day.",
      "Sunlight Sensitivity": "Has disadvantage on attack rolls and Wisdom (Perception) checks that rely on sight when you, the target of your attack, or whatever you are trying to perceive is in direct sunlight.",
      "Drow Weapon Training": "Has proficiency with rapiers, shortswords, and hand crossbows.",
      // Dwarf traits
      "Dwarven Toughness": "Hit point maximum increases by 1, and increases by 1 every time you gain a level.",
      "Dwarven Armor Training": "Has proficiency with light and medium armor.",
      // Halfling traits
      "Naturally Stealthy": "Can attempt to hide even when obscured only by a creature that is at least one size larger.",
      "Stout Resilience": "Has advantage on saving throws against poison, and has resistance against poison damage.",
      // Dragonborn traits
      "Draconic Ancestry": "Has draconic ancestry. Choose one type of dragon; your breath weapon and damage resistance are determined by the dragon type.",
      "Breath Weapon": "Can use your action to exhale destructive energy. Your draconic ancestry determines the size, shape, and damage type of the exhalation.",
      "Damage Resistance": "Has resistance to the damage type associated with your draconic ancestry.",
      // Gnome traits
      "Gnome Cunning": "Has advantage on all Intelligence, Wisdom, and Charisma saving throws against magic.",
      "Natural Illusionist": "Knows the minor illusion cantrip. Intelligence is your spellcasting ability for it.",
      "Speak with Small Beasts": "Can communicate simple ideas with Small or smaller beasts through sounds and gestures.",
      "Artificer's Lore": "Has doubled proficiency bonus when making Intelligence (History) checks related to magic items, alchemical objects, or technological devices.",
      "Tinker": "Has proficiency with artisan's tools (tinker's tools) and can use them to construct tiny clockwork devices.",
      // Half-orc traits
      "Menacing": "Has proficiency in the Intimidation skill.",
      "Relentless Endurance": "When reduced to 0 hit points but not killed outright, can drop to 1 hit point instead. Can't use this feature again until after a long rest.",
      "Savage Attacks": "When scoring a critical hit with a melee weapon attack, can roll one of the weapon's damage dice one additional time and add it to the extra damage.",
      // Tiefling traits
      "Hellish Resistance": "Has resistance to fire damage.",
      "Infernal Legacy": "Knows the thaumaturgy cantrip. At 3rd level, can cast hellish rebuke once per day. At 5th level, can cast darkness once per day.",
      // Aasimar traits
      "Celestial Resistance": "Has resistance to necrotic damage and radiant damage.",
      "Healing Hands": "As an action, can touch a creature and heal a total number of hit points equal to your level. Can't use this trait again until after a long rest.",
      "Light Bearer": "Knows the light cantrip.",
      "Radiant Soul": "Can unleash divine energy within yourself. Your eyes glimmer and two luminous, incorporeal wings emerge from your back.",
      "Radiant Consumption": "Can unleash divine energy within yourself, causing a searing light to radiate from you.",
      "Necrotic Shroud": "Can unleash divine energy within yourself, causing your eyes to turn into pools of darkness and two skeletal, ghostly wings to emerge from your back.",
      // Other races
      "Firbolg Magic": "Can cast detect magic and disguise self spells once per short rest.",
      "Hidden Step": "As a bonus action, can magically turn invisible until the start of your next turn or until you attack, make a damage roll, or force someone to make a saving throw.",
      "Powerful Build": "Counts as one size larger when determining your carrying capacity and the weight you can push, drag, or lift.",
      "Speech of Beast and Leaf": "Can communicate simple ideas with beasts and plants.",
      "Stone's Endurance": "Can focus to resist damage. When taking damage, can use your reaction to roll a d12, adding your Constitution modifier, and reduce the damage by that total.",
      "Mountain Born": "Has resistance to cold damage and are acclimated to high altitude.",
      "Natural Athlete": "Has proficiency in the Athletics skill.",
      "Feline Agility": "Your reflexes and agility allow you to move with a burst of speed.",
      "Cat's Claws": "Has retractable claws that are natural weapons, which can be used to make unarmed strikes.",
      "Cat's Talent": "Has proficiency in the Perception and Stealth skills.",
      "Expert Forgery": "Can duplicate other creatures' handwriting and craftwork.",
      "Mimicry": "Can mimic sounds you have heard, including voices.",
      "Kenku Training": "Has proficiency in two of the following skills of your choice: Acrobatics, Deception, Stealth, and Sleight of Hand.",
      "Amphibious": "Can breathe air and water.",
      "Control Air and Water": "Can cast fog cloud once per day. At 3rd level, can cast gust of wind once per day. At 5th level, can cast wall of water once per day.",
      "Emissary of the Sea": "Can communicate simple ideas with beasts that can breathe water.",
      "Guardians of the Depths": "Adapted to even the most extreme ocean depths.",
      "Claws": "Has retractable claws that are natural weapons, which can be used to make unarmed strikes.",
      "Hunter's Instincts": "Has proficiency in two of the following skills of your choice: Athletics, Perception, Stealth, or Survival.",
      "Daunting Roar": "As a bonus action, can let out an especially menacing roar.",
      "Fey": "Your creature type is fey, rather than humanoid.",
      "Magic Resistance": "Has advantage on saving throws against spells and other magical effects.",
      "Mirthful Leaps": "Whenever you make a long jump or high jump, you can roll a d8 and add the number rolled to the total distance in feet.",
      "Reveler": "Has proficiency in the Performance and Persuasion skills.",
      "Flight": "Has a flying speed of 30 feet. To use this speed, you can't be wearing medium or heavy armor.",
      "Fairy Magic": "Knows the druidcraft cantrip. Starting at 3rd level, can cast faerie fire once per day. Starting at 5th level, can cast enlarge/reduce once per day.",
      "Hare-Trigger": "Can add your proficiency bonus to your initiative rolls.",
      "Leporine Senses": "Has proficiency in the Perception skill.",
      "Lucky Footwork": "When you fail a Dexterity saving throw, you can use your reaction to roll a d4 and add it to the save.",
      "Rabbit Hop": "As a bonus action, can jump a number of feet equal to five times your proficiency bonus."
    };
    return traitDescriptions[trait] || `Racial trait of ${race}.`;
  }
};

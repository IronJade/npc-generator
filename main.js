/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NPCGenerator
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/utils/npc-generation.ts
var NPCGenerationUtils = class {
  /**
   * Roll ability scores using 4d6 drop lowest method
   * @returns AbilityScores object
   */
  static generateAbilityScores() {
    const rollAbilityScore = () => {
      const rolls = Array(4).fill(0).map(() => Math.floor(Math.random() * 6) + 1);
      rolls.sort((a, b) => a - b);
      rolls.shift();
      return rolls.reduce((a, b) => a + b, 0);
    };
    return {
      str: rollAbilityScore(),
      dex: rollAbilityScore(),
      con: rollAbilityScore(),
      int: rollAbilityScore(),
      wis: rollAbilityScore(),
      cha: rollAbilityScore()
    };
  }
  /**
   * Calculate ability modifiers
   * @param abilityScores 
   * @returns Partial ability modifiers
   */
  static calculateAbilityModifiers(abilityScores) {
    return Object.fromEntries(
      Object.entries(abilityScores).map(([ability, score]) => [
        ability,
        Math.floor((score - 10) / 2)
      ])
    );
  }
  /**
   * Generate a random alignment
   * @returns Alignment
   */
  static generateAlignment() {
    const lawfulness = ["Lawful", "Neutral", "Chaotic"];
    const goodness = ["Good", "Neutral", "Evil"];
    const lawChoice = lawfulness[Math.floor(Math.random() * lawfulness.length)];
    const goodChoice = goodness[Math.floor(Math.random() * goodness.length)];
    if (lawChoice === "Neutral" && goodChoice === "Neutral") {
      return "Neutral";
    }
    return `${lawChoice} ${goodChoice}`;
  }
  /**
   * Generate a name based on race
   * @param race Race object
   * @returns string
   */
  static generateName(race) {
    const namesByRace = {
      "Human": {
        first: ["James", "John", "Mary", "Emma", "Liam", "Olivia", "William", "Ava", "Sophia", "Lucas"],
        last: ["Smith", "Johnson", "Brown", "Williams", "Jones", "Miller", "Davis", "Garcia", "Rodriguez", "Wilson"]
      },
      "Elf": {
        first: ["Aerith", "Legolas", "Elrond", "Galadriel", "Thranduil", "Arwen", "Celeborn", "Tauriel", "Haldir", "F\xEBanor"],
        last: ["Silverleaf", "Starweaver", "Moonshadow", "Windrider", "Dawnbringer", "Nightwalker", "Sunseeker", "Forestborn", "Lightbringer", "Swiftarrow"]
      }
      // Add other races similarly...
    };
    const nameOptions = namesByRace[race.name] || namesByRace["Human"];
    const firstName = nameOptions.first[Math.floor(Math.random() * nameOptions.first.length)];
    const lastName = nameOptions.last[Math.floor(Math.random() * nameOptions.last.length)];
    return `${firstName} ${lastName}`;
  }
  /**
   * Calculate hit points for an NPC
   * @param characterClass Character's class
   * @param conModifier Constitution modifier
   * @param level Character level
   * @returns number
   */
  static calculateHitPoints(characterClass, conModifier, level) {
    const firstLevelHP = characterClass.hitDie + conModifier;
    const subsequentLevelsHP = (characterClass.hitDie / 2 + 1 + conModifier) * (level - 1);
    return Math.floor(firstLevelHP + subsequentLevelsHP);
  }
  /**
   * Calculate proficiency bonus based on level
   * @param level Character level
   * @returns number
   */
  static calculateProficiencyBonus(level) {
    return Math.ceil(level / 4) + 1;
  }
  /**
   * Apply racial ability score adjustments
   * @param baseScores Original ability scores
   * @param race Race with adjustments
   * @returns Adjusted ability scores
   */
  static applyRacialAdjustments(baseScores, race) {
    return {
      str: baseScores.str + (race.abilityScoreAdjustments.str || 0),
      dex: baseScores.dex + (race.abilityScoreAdjustments.dex || 0),
      con: baseScores.con + (race.abilityScoreAdjustments.con || 0),
      int: baseScores.int + (race.abilityScoreAdjustments.int || 0),
      wis: baseScores.wis + (race.abilityScoreAdjustments.wis || 0),
      cha: baseScores.cha + (race.abilityScoreAdjustments.cha || 0)
    };
  }
  /**
   * Generate skills for an NPC
   * @param characterClass Character's class
   * @param abilityModifiers Ability modifiers
   * @param level Character level
   * @returns Record of skills and their bonuses
   */
  static generateSkills(characterClass, abilityModifiers, level) {
    const allSkills = {
      "Acrobatics": "dex",
      "Animal Handling": "wis",
      "Arcana": "int",
      "Athletics": "str",
      "Deception": "cha",
      "History": "int",
      "Insight": "wis",
      "Intimidation": "cha",
      "Investigation": "int",
      "Medicine": "wis",
      "Nature": "int",
      "Perception": "wis",
      "Performance": "cha",
      "Persuasion": "cha",
      "Religion": "int",
      "Sleight of Hand": "dex",
      "Stealth": "dex",
      "Survival": "wis"
    };
    const proficiencyBonus = this.calculateProficiencyBonus(level);
    const skills = {};
    const classSkills = characterClass.skills;
    const numProficiencies = 2 + Math.floor(Math.random() * 3);
    const proficientSkills = [];
    while (proficientSkills.length < numProficiencies && classSkills.length > proficientSkills.length) {
      const skill = classSkills[Math.floor(Math.random() * classSkills.length)];
      if (!proficientSkills.includes(skill)) {
        proficientSkills.push(skill);
      }
    }
    for (const [skill, ability] of Object.entries(allSkills)) {
      const isProficient = proficientSkills.includes(skill);
      skills[skill] = (abilityModifiers[ability] || 0) + (isProficient ? proficiencyBonus : 0);
    }
    return skills;
  }
};

// src/utils/possessions.ts
var PossessionsUtils = class {
  /**
   * Generate possessions for an NPC
   * @param characterClass Character's class
   * @returns Array of possessions
   */
  static generatePossessions(characterClass) {
    const baseEquipment = this.classEquipment[characterClass.name] || this.classEquipment["Fighter"];
    if (Math.random() >= 0.75) {
      return this.addSpecialItems(baseEquipment);
    }
    return baseEquipment;
  }
  /**
   * Add special items to base equipment
   * @param baseEquipment Base equipment list
   * @returns Enhanced equipment list
   */
  static addSpecialItems(baseEquipment) {
    const availableSpecialItems = [...this.specialItems];
    const numSpecialItems = Math.floor(Math.random() * 3) + 1;
    const specialItemsToAdd = [];
    for (let i = 0; i < numSpecialItems; i++) {
      if (availableSpecialItems.length === 0) break;
      const randomIndex = Math.floor(Math.random() * availableSpecialItems.length);
      specialItemsToAdd.push(availableSpecialItems.splice(randomIndex, 1)[0]);
    }
    return [...baseEquipment, ...specialItemsToAdd];
  }
  /**
   * Format possessions for display
   * @param possessions List of possessions
   * @returns Formatted possession strings
   */
  static formatPossessions(possessions) {
    return possessions.map((item) => {
      if (typeof item === "string") return item;
      return item.desc ? `${item.name} (${item.desc})` : item.name;
    });
  }
};
/**
 * Base equipment for different classes
 */
PossessionsUtils.classEquipment = {
  "Fighter": [
    "Longsword",
    "Shield",
    "Chain mail",
    "Backpack",
    "Bedroll",
    "Tinderbox",
    "10 torches",
    "10 days of rations",
    "Waterskin",
    "50 ft of rope"
  ],
  "Rogue": [
    "Shortsword",
    "Shortbow with 20 arrows",
    "Leather armor",
    "Thieves' tools",
    "Backpack",
    "50 ft of silk rope",
    "Dark clothes",
    "Hood",
    "Belt pouch",
    "10 days of rations"
  ],
  "Wizard": [
    "Spellbook",
    "Quarterstaff",
    "Component pouch",
    "Scholar's pack",
    "Backpack",
    "Bottle of ink",
    "Ink pen",
    "10 sheets of parchment",
    "Little bag of sand",
    "Small knife"
  ],
  "Cleric": [
    "Mace",
    "Scale mail",
    "Shield",
    "Holy symbol",
    "Priest's pack",
    "Backpack",
    "Blanket",
    "10 candles",
    "Tinderbox",
    "Alms box"
  ],
  "Barbarian": [
    "Greataxe",
    "Two handaxes",
    "Explorer's pack",
    "Four javelins",
    "Backpack",
    "Bedroll",
    "Mess kit",
    "Tinderbox",
    "10 days of rations",
    "Waterskin"
  ]
};
/**
 * List of possible special items
 */
PossessionsUtils.specialItems = [
  { name: "gold pocket watch", desc: "valued at 10 Golds" },
  { name: "intricately carved wood pipe" },
  { name: "pouch half-filled with pipe weed that has a maple honey scent" },
  { name: "Potion of Greater Healing" },
  { name: "1 Plats, 12 Golds, 17 Lecs, and 5 Silvs in a leather purse" },
  { name: "mysterious key", desc: "made of a strange blue metal" },
  { name: "small trinket", desc: "from their hometown" }
];

// src/utils/spellcasting.ts
var SpellcastingUtils = class {
  /**
   * Determine if a class is a spellcaster
   * @param characterClass Character's class
   * @returns boolean
   */
  static isSpellcaster(characterClass) {
    return characterClass.name in this.spellcastingAbilities;
  }
  /**
   * Generate spellcasting information
   * @param characterClass Character's class
   * @param abilityModifiers Ability modifiers
   * @param level Character level
   * @returns Spellcasting object or null
   */
  static generateSpellcasting(characterClass, abilityModifiers, level) {
    const spellcastingAbility = this.spellcastingAbilities[characterClass.name];
    if (!spellcastingAbility) return null;
    const modifier = abilityModifiers[spellcastingAbility] || 0;
    const saveDC = 8 + Math.ceil(level / 4) + 1 + modifier;
    const attackBonus = Math.ceil(level / 4) + 1 + modifier;
    const cantripsKnown = Math.min(4, Math.floor(level / 4) + 2);
    const maxSlotLevel = Math.min(9, Math.ceil(level / 2));
    const slots = {};
    for (let i = 1; i <= maxSlotLevel; i++) {
      if (level < i * 2 - 1) continue;
      let slotCount = 0;
      if (i === 1) slotCount = Math.min(4, level);
      else if (i === 2) slotCount = Math.min(3, Math.floor((level - 2) / 2));
      else if (i === 3) slotCount = Math.min(3, Math.floor((level - 4) / 2));
      else if (i === 4) slotCount = Math.min(3, Math.floor((level - 6) / 2));
      else if (i === 5) slotCount = Math.min(3, Math.floor((level - 8) / 2));
      else if (i <= 9) slotCount = Math.min(1, Math.floor((level - 10) / 2));
      slots[i] = Math.max(0, slotCount);
    }
    return {
      ability: spellcastingAbility.toUpperCase(),
      saveDC,
      attackBonus,
      cantripsKnown,
      slots
    };
  }
  /**
   * Get spells for a given class and spell level
   * @param className Class name
   * @param spellLevel Spell level
   * @returns Array of spell names
   */
  static getSpellsByClassAndLevel(className, spellLevel) {
    var _a;
    return ((_a = this.spellsByClassAndLevel[className]) == null ? void 0 : _a[spellLevel]) || [];
  }
  /**
   * Get cantrips for a given class
   * @param className Class name
   * @returns Array of cantrip names
   */
  static getCantrips(className) {
    return this.cantrips[className] || [];
  }
};
/**
 * Spellcasting ability for different classes
 */
SpellcastingUtils.spellcastingAbilities = {
  "Wizard": "int",
  "Cleric": "wis",
  "Bard": "cha",
  "Druid": "wis",
  "Paladin": "cha",
  "Sorcerer": "cha",
  "Warlock": "cha"
};
/**
 * Predefined spell lists by class and level
 */
SpellcastingUtils.spellsByClassAndLevel = {
  "Wizard": {
    1: ["mage armor", "magic missile", "shield", "detect magic"],
    2: ["mirror image", "misty step", "web", "invisibility"],
    3: ["fireball", "counterspell", "fly", "haste"],
    4: ["polymorph", "greater invisibility", "ice storm", "banishment"],
    5: ["cone of cold", "wall of force", "teleportation circle", "scrying"],
    6: ["disintegrate", "globe of invulnerability", "chain lightning", "true seeing"],
    7: ["teleport", "finger of death", "simulacrum", "plane shift"],
    8: ["power word stun", "mind blank", "maze", "dominate monster"],
    9: ["wish", "time stop", "meteor swarm", "power word kill"]
  },
  "Cleric": {
    1: ["cure wounds", "guiding bolt", "healing word", "bless"],
    2: ["spiritual weapon", "prayer of healing", "lesser restoration", "hold person"],
    3: ["revivify", "mass healing word", "spirit guardians", "dispel magic"],
    4: ["guardian of faith", "death ward", "freedom of movement", "banishment"],
    5: ["flame strike", "greater restoration", "mass cure wounds", "raise dead"],
    6: ["heal", "harm", "heroes' feast", "word of recall"],
    7: ["divine word", "regenerate", "resurrection", "plane shift"],
    8: ["holy aura", "earthquake", "antimagic field", "control weather"],
    9: ["mass heal", "true resurrection", "gate", "power word heal"]
  }
};
/**
 * Predefined cantrips by class
 */
SpellcastingUtils.cantrips = {
  "Wizard": ["fire bolt", "mage hand", "prestidigitation", "minor illusion"],
  "Cleric": ["sacred flame", "guidance", "light", "thaumaturgy"]
};

// src/ui/modal.ts
var import_obsidian = require("obsidian");
var NPCGeneratorModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.npc = null;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Generate NPC" });
    const optionsContainer = contentEl.createDiv("npc-generation-options");
    const levelContainer = this.createLabeledInput(
      optionsContainer,
      "Level",
      "number",
      "1",
      { min: "1", max: "20" }
    );
    const levelInput = levelContainer.querySelector("input");
    const raceContainer = this.createLabeledSelect(
      optionsContainer,
      "Race",
      this.plugin.settings.races.map((race) => race.name)
    );
    const raceSelect = raceContainer.querySelector("select");
    const classContainer = this.createLabeledSelect(
      optionsContainer,
      "Class",
      this.plugin.settings.classes.map((characterClass) => characterClass.name)
    );
    const classSelect = classContainer.querySelector("select");
    const alignments = [
      "Lawful Good",
      "Neutral Good",
      "Chaotic Good",
      "Lawful Neutral",
      "Neutral",
      "Chaotic Neutral",
      "Lawful Evil",
      "Neutral Evil",
      "Chaotic Evil"
    ];
    const alignmentContainer = this.createLabeledSelect(
      optionsContainer,
      "Alignment",
      alignments
    );
    const alignmentSelect = alignmentContainer.querySelector("select");
    const customParamsContainer = contentEl.createDiv("custom-parameters");
    customParamsContainer.createEl("h3", { text: "Custom Parameters" });
    const enabledParams = this.plugin.settings.customParameters.filter((p) => p.enabled);
    if (enabledParams.length === 0) {
      customParamsContainer.createEl("p", {
        text: "No custom parameters enabled. Add parameters in plugin settings.",
        attr: { style: "color: #666; font-style: italic;" }
      });
    } else {
      enabledParams.forEach((param) => {
        if (["spellcasting", "possessions"].includes(param.name)) return;
        this.createLabeledInput(
          customParamsContainer,
          param.label,
          "text",
          "",
          { placeholder: `Enter ${param.label.toLowerCase()}` }
        );
      });
    }
    const buttonContainer = contentEl.createDiv("npc-generation-buttons");
    const generateButton = buttonContainer.createEl("button", { text: "Generate NPC" });
    generateButton.addEventListener("click", () => {
      const options = {
        level: parseInt(levelInput.value, 10),
        race: raceSelect.value,
        class: classSelect.value,
        alignment: alignmentSelect.value,
        customParameters: {}
      };
      enabledParams.forEach((param) => {
        if (["spellcasting", "possessions"].includes(param.name)) return;
        const input = customParamsContainer.querySelector(
          `input[placeholder="Enter ${param.label.toLowerCase()}"]`
        );
        if (input && input.value.trim()) {
          options.customParameters[param.name] = input.value.trim();
        }
      });
      try {
        this.npc = this.plugin.generateNPC(options);
        this.showResults();
      } catch (error) {
        console.error("NPC Generation Error:", error);
        new import_obsidian.Notice("Failed to generate NPC. Check console for details.");
      }
    });
    const randomButton = buttonContainer.createEl("button", { text: "Random NPC" });
    randomButton.addEventListener("click", () => {
      try {
        this.npc = this.plugin.generateNPC();
        this.showResults();
      } catch (error) {
        console.error("Random NPC Generation Error:", error);
        new import_obsidian.Notice("Failed to generate random NPC. Check console for details.");
      }
    });
  }
  /**
   * Create a labeled input element
   * @param container Parent container
   * @param label Input label
   * @param type Input type
   * @param defaultValue Default value
   * @param additionalAttributes Additional input attributes
   * @returns Container element
   */
  createLabeledInput(container, label, type, defaultValue = "", additionalAttributes = {}) {
    const inputContainer = container.createDiv("labeled-input");
    inputContainer.createEl("label", { text: label });
    inputContainer.createEl("input", {
      type,
      value: defaultValue,
      ...additionalAttributes
    });
    return inputContainer;
  }
  /**
   * Create a labeled select element
   * @param container Parent container
   * @param label Select label
   * @param options Select options
   * @returns Container element
   */
  createLabeledSelect(container, label, options) {
    const selectContainer = container.createDiv("labeled-select");
    selectContainer.createEl("label", { text: label });
    const select = selectContainer.createEl("select");
    options.forEach((option) => {
      select.createEl("option", {
        text: option,
        value: option
      });
    });
    return selectContainer;
  }
  /**
   * Display generated NPC results
   */
  showResults() {
    if (!this.npc) return;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: `${this.npc.name} (Level ${this.npc.level} ${this.npc.race} ${this.npc.class})`
    });
    const abilitiesContainer = contentEl.createDiv("npc-abilities");
    abilitiesContainer.createEl("h3", { text: "Ability Scores" });
    const abilitiesTable = abilitiesContainer.createEl("table");
    const headerRow = abilitiesTable.createEl("tr");
    ["STR", "DEX", "CON", "INT", "WIS", "CHA"].forEach((ability) => {
      headerRow.createEl("th", { text: ability });
    });
    const scoresRow = abilitiesTable.createEl("tr");
    ["str", "dex", "con", "int", "wis", "cha"].forEach((ability) => {
      const score = this.npc.abilityScores[ability];
      const modifier = this.npc.abilityModifiers[ability] || 0;
      scoresRow.createEl("td", {
        text: `${score} (${modifier >= 0 ? "+" : ""}${modifier})`
      });
    });
    const statblockContainer = contentEl.createDiv("npc-statblock");
    statblockContainer.createEl("h3", { text: "Statblock" });
    const statblockText = statblockContainer.createEl("textarea", {
      text: this.plugin.formatStatblock(this.npc)
    });
    statblockText.setAttribute("readonly", "true");
    statblockText.style.width = "100%";
    statblockText.style.height = "300px";
    statblockText.style.fontFamily = "monospace";
    const insertButton = contentEl.createEl("button", { text: "Insert into Current Note" });
    insertButton.addEventListener("click", this.insertStatblockIntoNote.bind(this));
    const backButton = contentEl.createEl("button", { text: "Generate Another NPC" });
    backButton.addEventListener("click", () => this.onOpen());
  }
  /**
   * Insert statblock into the current active note
   */
  insertStatblockIntoNote() {
    if (!this.npc) return;
    try {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile) {
        throw new Error("No active file");
      }
      const activeEditor = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeEditor) {
        throw new Error("No active editor");
      }
      const editor = activeEditor.editor;
      editor.replaceSelection(this.plugin.formatStatblock(this.npc));
      this.close();
      new import_obsidian.Notice("NPC statblock inserted!");
    } catch (error) {
      console.error("Insert Statblock Error:", error);
      new import_obsidian.Notice("Failed to insert statblock. Please ensure a note is open.");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/settings-tab.ts
var import_obsidian2 = require("obsidian");
var NPCGeneratorSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "NPC Generator Settings" });
    this.addStatblockFormatSection();
    this.addRacesSection();
    this.addClassesSection();
    this.addCustomParametersSection();
  }
  /**
   * Add Statblock Format Selection
   */
  addStatblockFormatSection() {
    const statblockSection = this.containerEl.createDiv("statblock-format-section");
    statblockSection.createEl("h2", { text: "Statblock Format" });
    new import_obsidian2.Setting(statblockSection).setName("Choose Statblock Style").setDesc("Select the format for generated NPC statblocks").addDropdown((dropdown) => {
      dropdown.addOption("fantasyStatblock", "Fantasy Statblock").addOption("basic", "Basic Text").setValue(this.plugin.settings.statblockFormat).onChange(async (value) => {
        this.plugin.settings.statblockFormat = value;
        await this.plugin.saveSettings();
      });
    });
  }
  /**
   * Add Races Management Section
   */
  addRacesSection() {
    const racesSection = this.containerEl.createDiv("races-section");
    racesSection.createEl("h2", { text: "Races" });
    new import_obsidian2.Setting(racesSection).setName("Add New Race").setDesc("Create a new playable race for NPC generation").addButton((button) => {
      return button.setButtonText("Add Race").onClick(() => this.openRaceModal());
    });
    this.plugin.settings.races.forEach((race, index) => {
      new import_obsidian2.Setting(racesSection).setName(race.name).setDesc(this.formatRaceDescription(race)).addButton((button) => {
        return button.setButtonText("Edit").onClick(() => this.openRaceModal(race, index));
      }).addButton((button) => {
        return button.setButtonText("Delete").setClass("warning").onClick(async () => {
          if (confirm(`Are you sure you want to delete the ${race.name} race?`)) {
            this.plugin.settings.races.splice(index, 1);
            await this.plugin.saveSettings();
            this.display();
          }
        });
      });
    });
  }
  /**
   * Add Classes Management Section
   */
  addClassesSection() {
    const classesSection = this.containerEl.createDiv("classes-section");
    classesSection.createEl("h2", { text: "Classes" });
    new import_obsidian2.Setting(classesSection).setName("Add New Class").setDesc("Create a new character class for NPC generation").addButton((button) => {
      return button.setButtonText("Add Class").onClick(() => this.openClassModal());
    });
    this.plugin.settings.classes.forEach((characterClass, index) => {
      new import_obsidian2.Setting(classesSection).setName(characterClass.name).setDesc(this.formatClassDescription(characterClass)).addButton((button) => {
        return button.setButtonText("Edit").onClick(() => this.openClassModal(characterClass, index));
      }).addButton((button) => {
        return button.setButtonText("Delete").setClass("warning").onClick(async () => {
          if (confirm(`Are you sure you want to delete the ${characterClass.name} class?`)) {
            this.plugin.settings.classes.splice(index, 1);
            await this.plugin.saveSettings();
            this.display();
          }
        });
      });
    });
  }
  /**
   * Add Custom Parameters Management Section
   */
  addCustomParametersSection() {
    const customParamsSection = this.containerEl.createDiv("custom-parameters-section");
    customParamsSection.createEl("h2", { text: "Custom Parameters" });
    new import_obsidian2.Setting(customParamsSection).setName("Add Custom Parameter").setDesc("Create a new custom parameter for NPC generation").addButton((button) => {
      return button.setButtonText("Add Parameter").onClick(() => this.openCustomParameterModal());
    });
    const customParams = this.plugin.settings.customParameters.filter(
      (param) => param.name !== "spellcasting" && param.name !== "possessions"
    );
    if (customParams.length === 0) {
      customParamsSection.createEl("p", {
        text: "No custom parameters defined.",
        attr: { style: "color: #666; font-style: italic; text-align: center;" }
      });
    } else {
      customParams.forEach((param) => {
        new import_obsidian2.Setting(customParamsSection).setName(param.label).setDesc(`Name: ${param.name}, Format: ${param.format}`).addToggle((toggle) => {
          toggle.setValue(param.enabled).onChange(async (value) => {
            param.enabled = value;
            await this.plugin.saveSettings();
          });
        }).addButton((button) => {
          return button.setButtonText("Edit").onClick(() => this.openCustomParameterModal(param));
        }).addButton((button) => {
          return button.setButtonText("Delete").setClass("warning").onClick(async () => {
            if (confirm(`Are you sure you want to delete the ${param.label} parameter?`)) {
              this.plugin.settings.customParameters.splice(
                this.plugin.settings.customParameters.indexOf(param),
                1
              );
              await this.plugin.saveSettings();
              this.display();
            }
          });
        });
      });
    }
  }
  /**
   * Open Race Modal for Adding/Editing
   */
  openRaceModal(existingRace, index) {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText(existingRace ? `Edit ${existingRace.name} Race` : "Add New Race");
    new import_obsidian2.Setting(modal.contentEl).setName("Race Name").addText((text) => {
      text.setValue((existingRace == null ? void 0 : existingRace.name) || "").onChange((value) => {
        if (existingRace) existingRace.name = value;
      });
    });
    const abilities = ["str", "dex", "con", "int", "wis", "cha"];
    abilities.forEach((ability) => {
      new import_obsidian2.Setting(modal.contentEl).setName(`${ability.toUpperCase()} Adjustment`).addSlider((slider) => {
        slider.setLimits(-2, 2, 1).setValue((existingRace == null ? void 0 : existingRace.abilityScoreAdjustments[ability]) || 0).setDynamicTooltip().onChange((value) => {
          if (existingRace) {
            existingRace.abilityScoreAdjustments[ability] = value;
          }
        });
      });
    });
    const traitsContainer = modal.contentEl.createDiv("race-traits");
    traitsContainer.createEl("h3", { text: "Racial Traits" });
    const traitsList = traitsContainer.createEl("ul");
    ((existingRace == null ? void 0 : existingRace.traits) || []).forEach((trait, traitIndex) => {
      const traitItem = traitsList.createEl("li");
      traitItem.createEl("span", { text: trait });
      traitItem.createEl("button", {
        text: "\xD7",
        attr: { style: "margin-left: 10px; color: red;" }
      }).addEventListener("click", () => {
        if (existingRace) {
          existingRace.traits.splice(traitIndex, 1);
          traitItem.remove();
        }
      });
    });
    const newTraitContainer = modal.contentEl.createDiv("new-trait-input");
    const traitInput = newTraitContainer.createEl("input", {
      type: "text",
      placeholder: "Add a new trait"
    });
    const addTraitButton = newTraitContainer.createEl("button", { text: "Add Trait" });
    addTraitButton.addEventListener("click", () => {
      const newTrait = traitInput.value.trim();
      if (newTrait) {
        if (!existingRace) {
          existingRace = {
            name: "",
            abilityScoreAdjustments: { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 },
            traits: []
          };
        }
        existingRace.traits.push(newTrait);
        const traitItem = traitsList.createEl("li");
        traitItem.createEl("span", { text: newTrait });
        traitItem.createEl("button", {
          text: "\xD7",
          attr: { style: "margin-left: 10px; color: red;" }
        }).addEventListener("click", () => {
          existingRace.traits.splice(existingRace.traits.length - 1, 1);
          traitItem.remove();
        });
        traitInput.value = "";
      }
    });
    const saveButton = modal.contentEl.createEl("button", { text: "Save" });
    saveButton.addEventListener("click", async () => {
      if (!existingRace || !existingRace.name) {
        new import_obsidian2.Notice("Race name is required");
        return;
      }
      if (index !== void 0) {
        this.plugin.settings.races[index] = existingRace;
      } else {
        this.plugin.settings.races.push(existingRace);
      }
      await this.plugin.saveSettings();
      this.display();
      modal.close();
    });
    modal.open();
  }
  /**
   * Open Class Modal for Adding/Editing
   */
  openClassModal(existingClass, index) {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText(existingClass ? `Edit ${existingClass.name} Class` : "Add New Class");
    new import_obsidian2.Setting(modal.contentEl).setName("Class Name").addText((text) => {
      text.setValue((existingClass == null ? void 0 : existingClass.name) || "").onChange((value) => {
        if (existingClass) existingClass.name = value;
      });
    });
    new import_obsidian2.Setting(modal.contentEl).setName("Hit Die").addDropdown((dropdown) => {
      dropdown.addOption("6", "d6").addOption("8", "d8").addOption("10", "d10").addOption("12", "d12").setValue(((existingClass == null ? void 0 : existingClass.hitDie) || 8).toString()).onChange((value) => {
        if (existingClass) existingClass.hitDie = parseInt(value);
      });
    });
    new import_obsidian2.Setting(modal.contentEl).setName("Primary Ability").addDropdown((dropdown) => {
      dropdown.addOption("str", "STR").addOption("dex", "DEX").addOption("con", "CON").addOption("int", "INT").addOption("wis", "WIS").addOption("cha", "CHA").setValue((existingClass == null ? void 0 : existingClass.primaryAbility) || "str").onChange((value) => {
        if (existingClass) existingClass.primaryAbility = value;
      });
    });
    const savingThrowsContainer = modal.contentEl.createDiv("saving-throws");
    savingThrowsContainer.createEl("h3", { text: "Saving Throws" });
    const abilityNames = ["str", "dex", "con", "int", "wis", "cha"];
    const savingThrowCheckboxes = {};
    abilityNames.forEach((ability) => {
      const setting = new import_obsidian2.Setting(savingThrowsContainer).setName(ability.toUpperCase());
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = (existingClass == null ? void 0 : existingClass.savingThrows.includes(ability)) || false;
      setting.controlEl.appendChild(checkbox);
      savingThrowCheckboxes[ability] = checkbox;
    });
    const skillsContainer = modal.contentEl.createDiv("class-skills");
    skillsContainer.createEl("h3", { text: "Class Skills" });
    const allSkills = [
      "Acrobatics",
      "Animal Handling",
      "Arcana",
      "Athletics",
      "Deception",
      "History",
      "Insight",
      "Intimidation",
      "Investigation",
      "Medicine",
      "Nature",
      "Perception",
      "Performance",
      "Persuasion",
      "Religion",
      "Sleight of Hand",
      "Stealth",
      "Survival"
    ];
    const skillCheckboxes = {};
    allSkills.forEach((skill) => {
      const setting = new import_obsidian2.Setting(skillsContainer).setName(skill);
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = (existingClass == null ? void 0 : existingClass.skills.includes(skill)) || false;
      setting.controlEl.appendChild(checkbox);
      skillCheckboxes[skill] = checkbox;
    });
    const saveButton = modal.contentEl.createEl("button", { text: "Save" });
    saveButton.addEventListener("click", async () => {
      if (!existingClass || !existingClass.name) {
        new import_obsidian2.Notice("Class name is required");
        return;
      }
      existingClass.savingThrows = abilityNames.filter(
        (ability) => savingThrowCheckboxes[ability].checked
      );
      existingClass.skills = allSkills.filter(
        (skill) => skillCheckboxes[skill].checked
      );
      if (index !== void 0) {
        this.plugin.settings.classes[index] = existingClass;
      } else {
        this.plugin.settings.classes.push(existingClass);
      }
      await this.plugin.saveSettings();
      this.display();
      modal.close();
    });
    modal.open();
  }
  /**
   * Open Custom Parameter Modal for Adding/Editing
   */
  openCustomParameterModal(existingParam) {
    var _a;
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText(existingParam ? `Edit ${existingParam.label} Parameter` : "Add New Custom Parameter");
    const nameContainer = modal.contentEl.createDiv("parameter-name");
    nameContainer.createEl("h3", { text: "Parameter Identification" });
    const nameInput = nameContainer.createEl("input", {
      type: "text",
      placeholder: "Internal parameter name (lowercase, no spaces)",
      value: (existingParam == null ? void 0 : existingParam.name) || ""
    });
    nameContainer.createEl("div", {
      attr: {
        style: "color: red; display: none;",
        id: "name-error"
      }
    });
    const validateName = () => {
      const name = nameInput.value.trim().toLowerCase();
      const nameErrorEl = document.getElementById("name-error");
      if (!nameErrorEl) return false;
      if (!name) {
        nameErrorEl.textContent = "Parameter name is required";
        nameErrorEl.style.display = "block";
        return false;
      }
      const validNameRegex = /^[a-z0-9_]+$/;
      if (!validNameRegex.test(name)) {
        nameErrorEl.textContent = "Name must contain only lowercase letters, numbers, and underscores";
        nameErrorEl.style.display = "block";
        return false;
      }
      const existingNames = this.plugin.settings.customParameters.filter((p) => p !== existingParam).map((p) => p.name);
      if (existingNames.includes(name)) {
        nameErrorEl.textContent = "Parameter name must be unique";
        nameErrorEl.style.display = "block";
        return false;
      }
      nameErrorEl.style.display = "none";
      return true;
    };
    nameInput.addEventListener("blur", validateName);
    const labelContainer = modal.contentEl.createDiv("parameter-label");
    labelContainer.createEl("h3", { text: "Display Settings" });
    const labelInput = labelContainer.createEl("input", {
      type: "text",
      placeholder: "Label to display in UI",
      value: (existingParam == null ? void 0 : existingParam.label) || ""
    });
    const formatContainer = modal.contentEl.createDiv("parameter-format");
    formatContainer.createEl("h3", { text: "Formatting" });
    const formatInput = formatContainer.createEl("input", {
      type: "text",
      placeholder: 'Format template (e.g., "- {content}")',
      value: (existingParam == null ? void 0 : existingParam.format) || '- "{content}"'
    });
    formatContainer.createEl("p", {
      text: "Use {content} for single values or {item} for list items",
      attr: { style: "color: #666; font-size: 0.8em;" }
    });
    const previewContainer = modal.contentEl.createDiv("parameter-preview");
    previewContainer.createEl("h3", { text: "Preview" });
    const previewOutput = previewContainer.createEl("div", {
      attr: {
        style: "background: #f0f0f0; padding: 10px; border-radius: 5px; font-family: monospace;"
      }
    });
    const updatePreview = () => {
      const format = formatInput.value || '- "{content}"';
      previewOutput.textContent = format.replace("{content}", "Example content").replace("{item}", "Example item");
    };
    formatInput.addEventListener("input", updatePreview);
    updatePreview();
    const enabledContainer = modal.contentEl.createDiv("parameter-enabled");
    enabledContainer.createEl("h3", { text: "Visibility" });
    const enabledToggle = document.createElement("input");
    enabledToggle.type = "checkbox";
    enabledToggle.checked = (_a = existingParam == null ? void 0 : existingParam.enabled) != null ? _a : true;
    enabledContainer.appendChild(enabledToggle);
    enabledContainer.createEl("label", {
      text: " Enabled (visible in NPC generation)",
      attr: { style: "margin-left: 10px;" }
    });
    const saveButton = modal.contentEl.createEl("button", { text: "Save" });
    saveButton.addEventListener("click", async () => {
      if (!validateName()) return;
      const paramToSave = {
        name: nameInput.value.trim().toLowerCase(),
        label: labelInput.value.trim() || "Custom Parameter",
        format: formatInput.value.trim() || '- "{content}"',
        enabled: enabledToggle.checked
      };
      if (existingParam) {
        const paramIndex = this.plugin.settings.customParameters.indexOf(existingParam);
        this.plugin.settings.customParameters[paramIndex] = paramToSave;
      } else {
        this.plugin.settings.customParameters.push(paramToSave);
      }
      await this.plugin.saveSettings();
      this.display();
      modal.close();
    });
    const cancelButton = modal.contentEl.createEl("button", {
      text: "Cancel",
      attr: { style: "margin-left: 10px;" }
    });
    cancelButton.addEventListener("click", () => modal.close());
    modal.open();
  }
  /**
   * Format race description for display
   */
  formatRaceDescription(race) {
    const bonuses = Object.entries(race.abilityScoreAdjustments).filter(([_, value]) => value !== 0).map(([ability, value]) => `${ability.toUpperCase()} ${value > 0 ? "+" + value : value}`).join(", ");
    const traits = race.traits.length ? race.traits.join(", ") : "None";
    return `Ability Adjustments: ${bonuses || "None"}, Traits: ${traits}`;
  }
  /**
   * Format class description for display
   */
  formatClassDescription(characterClass) {
    return `Hit Die: d${characterClass.hitDie}, Primary: ${characterClass.primaryAbility.toUpperCase()}, Skills: ${characterClass.skills.length}`;
  }
};

// src/main.ts
var NPCGenerator = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.settings = {};
  }
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("dice", "Generate NPC", () => {
      new NPCGeneratorModal(this.app, this).open();
    });
    this.addSettingTab(new NPCGeneratorSettingsTab(this.app, this));
    this.addCommand({
      id: "generate-npc",
      name: "Generate NPC",
      callback: () => {
        new NPCGeneratorModal(this.app, this).open();
      }
    });
  }
  async loadSettings() {
    const defaultSettings = {
      races: [
        {
          name: "Human",
          abilityScoreAdjustments: { str: 1, dex: 1, con: 1, int: 1, wis: 1, cha: 1 },
          traits: []
        },
        {
          name: "Elf",
          abilityScoreAdjustments: { dex: 2, int: 1 },
          traits: ["Darkvision", "Fey Ancestry"]
        }
        // Add other default races...
      ],
      classes: [
        {
          name: "Fighter",
          hitDie: 10,
          primaryAbility: "str",
          savingThrows: ["str", "con"],
          skills: ["Athletics", "Intimidation", "Perception"]
        }
        // Add other default classes...
      ],
      customParameters: [],
      statblockFormat: "fantasyStatblock"
    };
    this.settings = Object.assign({}, defaultSettings, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Generate an NPC based on provided options
   * @param options Generation options
   * @returns Generated NPC
   */
  generateNPC(options = {}) {
    var _a;
    const defaults = {
      level: Math.floor(Math.random() * 20) + 1,
      race: this.getRandomRace().name,
      class: this.getRandomClass().name,
      alignment: NPCGenerationUtils.generateAlignment()
    };
    const mergedOptions = { ...defaults, ...options };
    const race = this.settings.races.find((r) => r.name === mergedOptions.race);
    const characterClass = this.settings.classes.find((c) => c.name === mergedOptions.class);
    let abilityScores = NPCGenerationUtils.generateAbilityScores();
    abilityScores = NPCGenerationUtils.applyRacialAdjustments(abilityScores, race);
    const abilityModifiers = NPCGenerationUtils.calculateAbilityModifiers(abilityScores);
    const hitPoints = NPCGenerationUtils.calculateHitPoints(
      characterClass,
      (_a = abilityModifiers.con) != null ? _a : 0,
      mergedOptions.level
    );
    const skills = NPCGenerationUtils.generateSkills(
      characterClass,
      abilityModifiers,
      mergedOptions.level
    );
    const proficiencyBonus = NPCGenerationUtils.calculateProficiencyBonus(mergedOptions.level);
    const name = NPCGenerationUtils.generateName(race);
    const possessions = PossessionsUtils.generatePossessions(characterClass);
    const spellcasting = SpellcastingUtils.isSpellcaster(characterClass) ? SpellcastingUtils.generateSpellcasting(
      characterClass,
      abilityModifiers,
      mergedOptions.level
    ) : void 0;
    const customParameters = {};
    if (spellcasting) {
      customParameters.spellcasting = spellcasting;
    }
    return {
      name,
      level: mergedOptions.level,
      race: race.name,
      class: characterClass.name,
      alignment: mergedOptions.alignment,
      abilityScores,
      abilityModifiers,
      hitPoints,
      proficiencyBonus,
      skills,
      traits: race.traits,
      possessions,
      customParameters
    };
  }
  /**
   * Get a random race from settings
   * @returns Race
   */
  getRandomRace() {
    return this.settings.races[Math.floor(Math.random() * this.settings.races.length)];
  }
  /**
   * Get a random class from settings
   * @returns CharacterClass
   */
  getRandomClass() {
    return this.settings.classes[Math.floor(Math.random() * this.settings.classes.length)];
  }
  /**
   * Format NPC statblock
   * @param npc NPC to format
   * @returns Formatted statblock string
   */
  formatStatblock(npc) {
    if (this.settings.statblockFormat === "fantasyStatblock") {
      return this.formatFantasyStatblock(npc);
    } else {
      return this.formatBasicStatblock(npc);
    }
  }
  /**
   * Format NPC using Fantasy Statblock format
   * @param npc NPC to format
   * @returns Formatted Fantasy Statblock string
   */
  formatFantasyStatblock(npc) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    return `---
name: ${npc.name}
size: Medium
type: humanoid
alignment: ${npc.alignment}
ac: ${10 + ((_a = npc.abilityModifiers.dex) != null ? _a : 0)}
hp: ${npc.hitPoints}
hit_dice: ${npc.level}d${((_b = this.settings.classes.find((c) => c.name === npc.class)) == null ? void 0 : _b.hitDie) || 8}
speed: 30 ft.
stats: [${npc.abilityScores.str}, ${npc.abilityScores.dex}, ${npc.abilityScores.con}, ${npc.abilityScores.int}, ${npc.abilityScores.wis}, ${npc.abilityScores.cha}]
skillsaves:
${Object.entries(npc.skills).filter(([_, value]) => value !== 0).map(([skill, bonus]) => `  "${skill}": ${bonus >= 0 ? "+" + bonus : bonus}`).join("\n")}
damage_resistances: 
condition_immunities: 
senses: passive Perception ${10 + ((_c = npc.skills["Perception"]) != null ? _c : 0)}
languages: Common
cr: ${Math.max(1, Math.floor(npc.level / 4))}
---

# ${npc.name}
*Level ${npc.level} ${npc.race} ${npc.class}, ${npc.alignment}*

**Armor Class** ${10 + ((_d = npc.abilityModifiers.dex) != null ? _d : 0)}
**Hit Points** ${npc.hitPoints} (${npc.level}d${((_e = this.settings.classes.find((c) => c.name === npc.class)) == null ? void 0 : _e.hitDie) || 8} + ${npc.level * ((_f = npc.abilityModifiers.con) != null ? _f : 0)})
**Speed** 30 ft.

|STR|DEX|CON|INT|WIS|CHA|
|:---:|:---:|:---:|:---:|:---:|:---:|
|${npc.abilityScores.str} (${((_g = npc.abilityModifiers.str) != null ? _g : 0) >= 0 ? "+" + ((_h = npc.abilityModifiers.str) != null ? _h : 0) : (_i = npc.abilityModifiers.str) != null ? _i : 0})|${npc.abilityScores.dex} (${((_j = npc.abilityModifiers.dex) != null ? _j : 0) >= 0 ? "+" + ((_k = npc.abilityModifiers.dex) != null ? _k : 0) : (_l = npc.abilityModifiers.dex) != null ? _l : 0})|${npc.abilityScores.con} (${((_m = npc.abilityModifiers.con) != null ? _m : 0) >= 0 ? "+" + ((_n = npc.abilityModifiers.con) != null ? _n : 0) : (_o = npc.abilityModifiers.con) != null ? _o : 0})|${npc.abilityScores.int} (${((_p = npc.abilityModifiers.int) != null ? _p : 0) >= 0 ? "+" + ((_q = npc.abilityModifiers.int) != null ? _q : 0) : (_r = npc.abilityModifiers.int) != null ? _r : 0})|${npc.abilityScores.wis} (${((_s = npc.abilityModifiers.wis) != null ? _s : 0) >= 0 ? "+" + ((_t = npc.abilityModifiers.wis) != null ? _t : 0) : (_u = npc.abilityModifiers.wis) != null ? _u : 0})|${npc.abilityScores.cha} (${((_v = npc.abilityModifiers.cha) != null ? _v : 0) >= 0 ? "+" + ((_w = npc.abilityModifiers.cha) != null ? _w : 0) : (_x = npc.abilityModifiers.cha) != null ? _x : 0})|

**Skills** ${Object.entries(npc.skills).filter(([_, value]) => value !== 0).map(([skill, bonus]) => `${skill} ${bonus >= 0 ? "+" + bonus : bonus}`).join(", ")}
**Senses** passive Perception ${10 + ((_y = npc.skills["Perception"]) != null ? _y : 0)}
**Languages** Common
**Challenge** ${Math.max(1, Math.floor(npc.level / 4))} (${Math.max(200, npc.level * 50)} XP)
**Proficiency Bonus** +${npc.proficiencyBonus}

${npc.traits.length > 0 ? "## Traits\n\n" + npc.traits.map((trait) => `***${trait}.*** Racial trait description.`).join("\n\n") + "\n\n" : ""}
${npc.customParameters.spellcasting ? `## Spellcasting

The NPC is a level ${npc.level} spellcaster. Its spellcasting ability is ${npc.customParameters.spellcasting.ability} (spell save DC ${npc.customParameters.spellcasting.saveDC}, ${npc.customParameters.spellcasting.attackBonus >= 0 ? "+" + npc.customParameters.spellcasting.attackBonus : npc.customParameters.spellcasting.attackBonus} to hit with spell attacks). It has the following spells prepared:

Cantrips (at will): ${SpellcastingUtils.getCantrips(npc.class).slice(0, npc.customParameters.spellcasting.cantripsKnown).join(", ")}
` + Object.entries(npc.customParameters.spellcasting.slots).filter(([_, slots]) => slots > 0).map(
      ([level, slots]) => `${getOrdinal(parseInt(level))} level (${slots} slots): ${SpellcastingUtils.getSpellsByClassAndLevel(npc.class, parseInt(level)).slice(0, Math.min(4, slots + 1)).join(", ")}`
    ).join("\n") + "\n\n" : ""}

## Possessions
${PossessionsUtils.formatPossessions(npc.possessions).map((item) => `* ${item}`).join("\n")}
`;
  }
  /**
   * Format NPC using Basic Text format
   * @param npc NPC to format
   * @returns Formatted Basic Text string
   */
  formatBasicStatblock(npc) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    return `# ${npc.name}
Level ${npc.level} ${npc.race} ${npc.class} (${npc.alignment})

**Ability Scores**
- STR: ${npc.abilityScores.str} (${((_a = npc.abilityModifiers.str) != null ? _a : 0) >= 0 ? "+" + ((_b = npc.abilityModifiers.str) != null ? _b : 0) : (_c = npc.abilityModifiers.str) != null ? _c : 0})
- DEX: ${npc.abilityScores.dex} (${((_d = npc.abilityModifiers.dex) != null ? _d : 0) >= 0 ? "+" + ((_e = npc.abilityModifiers.dex) != null ? _e : 0) : (_f = npc.abilityModifiers.dex) != null ? _f : 0})
- CON: ${npc.abilityScores.con} (${((_g = npc.abilityModifiers.con) != null ? _g : 0) >= 0 ? "+" + ((_h = npc.abilityModifiers.con) != null ? _h : 0) : (_i = npc.abilityModifiers.con) != null ? _i : 0})
- INT: ${npc.abilityScores.int} (${((_j = npc.abilityModifiers.int) != null ? _j : 0) >= 0 ? "+" + ((_k = npc.abilityModifiers.int) != null ? _k : 0) : (_l = npc.abilityModifiers.int) != null ? _l : 0})
- WIS: ${npc.abilityScores.wis} (${((_m = npc.abilityModifiers.wis) != null ? _m : 0) >= 0 ? "+" + ((_n = npc.abilityModifiers.wis) != null ? _n : 0) : (_o = npc.abilityModifiers.wis) != null ? _o : 0})
- CHA: ${npc.abilityScores.cha} (${((_p = npc.abilityModifiers.cha) != null ? _p : 0) >= 0 ? "+" + ((_q = npc.abilityModifiers.cha) != null ? _q : 0) : (_r = npc.abilityModifiers.cha) != null ? _r : 0})

**Core Stats**
- HP: ${npc.hitPoints}
- AC: ${10 + ((_s = npc.abilityModifiers.dex) != null ? _s : 0)}
- Proficiency: +${npc.proficiencyBonus}

**Skills**
${Object.entries(npc.skills).filter(([_, value]) => value !== 0).map(([skill, bonus]) => `- ${skill}: ${bonus >= 0 ? "+" + bonus : bonus}`).join("\n")}

${npc.traits.length > 0 ? "**Racial Traits**\n" + npc.traits.map((trait) => `- ${trait}`).join("\n") + "\n\n" : ""}
${npc.customParameters.spellcasting ? `**Spellcasting**
- Ability: ${npc.customParameters.spellcasting.ability}
- Save DC: ${npc.customParameters.spellcasting.saveDC}
- Attack Bonus: ${npc.customParameters.spellcasting.attackBonus >= 0 ? "+" + npc.customParameters.spellcasting.attackBonus : npc.customParameters.spellcasting.attackBonus}
- Cantrips Known: ${SpellcastingUtils.getCantrips(npc.class).slice(0, npc.customParameters.spellcasting.cantripsKnown).join(", ")}
- Spell Slots: ${Object.entries(npc.customParameters.spellcasting.slots).filter(([_, slots]) => slots > 0).map(([level, slots]) => `${level}${getOrdinal(parseInt(level)).slice(-2)} (${slots})`).join(", ")}

` : ""}

**Possessions**
${PossessionsUtils.formatPossessions(npc.possessions).map((item) => `- ${item}`).join("\n")}
`;
  }
};
function getOrdinal(n) {
  const suffixes = ["th", "st", "nd", "rd"];
  const remainder = n % 100;
  return n + (suffixes[(remainder - 20) % 10] || suffixes[remainder] || suffixes[0]);
}
